# 记录

- 2022年2月22日下午和晚上，算法-栈与队列

- 2022年2月23日晚上，算法-栈与队列
  - **C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树**，所以map、set的增删操作时间时间复杂度是logn，注意我这里没有说unordered_map、unordered_set，unordered_map、unordered_map底层实现是哈希表。
  
- 2022年2月24日下午晚上，二叉树DFS&BFS
  
  - 在处理类似于头结点、max初始化时，如何更加简洁的书写
    - 515,116
  
- 2022年3月2日上午，二叉树

  - 617

    - 考虑树的题目，不需要考虑很多结点，而是考虑到所有情况。结点数量选一个父子节点即可（递归的思路）

  - 700

    - 二叉搜索树
    - 注意二叉搜索树的性质

  - 98

    - 判断是不是二叉搜索树

    - 这里出现了定义和性质的混淆

    - 性质是

      - 根节点的值大于左儿子的值，小于右儿子的值

      - 但这个不能用来判断是不是二叉搜索树

      - 例如

      - ```bash
           5
         4	6
           3  7
        ```

      - 满足性质，不是二叉搜索树（3小于5）

    - 定义是

      - 比根节点小的值都进入左侧，比根节点大的值都进入右侧
      - 左右子树也满足这两个条件

    - 二叉搜索树中不能有相等的元素

    - 采用中序遍历

      - 可以是递归+数组
      - 也可以迭代（比较不好理解）

  - 530

    - 最小差值

    - 一个语言bug

    - ​    // error:node *p = root, *pre;

      ​    // 因为pre指针没有初始化，可能指向一个危险的区域

      ​    // 实际上通过debug发现该指针确实指向一个低地址0x0018

      ​    node *p = *root*, *pre = nullptr;

  - 501 + 一个求众数的代码

    - 可以先遍历一次，更新map的内容，然后将key-value作为pair放到vector中，对vector排序
      - 找到所有频率等于maxCount的
    - 可以先排序
      - 然后遍历一次
      - 设置count和maxCount
    - 可以先排序
      - 遍历一次，找到maxCount
      - 然后再遍历一次，找到频率和maxCount相等的

  - 236，一般二叉树找祖先

    - 典型的递归
      - 可以判断pq是在同侧还是异侧
        - 这是一个自上而下的顺序
      - 也可以用后序遍历
        - 因为找祖先是一个自下而上的过程，二叉树不能自下而上，只能自上而下
        - 后序遍历可以起到回溯的效果

  - 235，二叉搜索树找祖先

    - 比一般二叉树找祖先容易，因为BST自带大小比较
    - 递归
      - 利用二叉搜索树自带的方向性
    - 迭代
      - 同样如此

  - 701，BST插入

    - 很简单，但是能否用遍历的套路来解决这个问题呢？
      - 递归
      - 迭代
        - 找到插入点后，需要知道插入点的父结点
        - 所以还需要一个指针记录父结点
    - 一般引申的问题是，插入后如何保持BST的平衡

  - 450，BST删除

    - 删除的策略

      - 删除节点需要知道被删除结点及其父结点
      - 如果被删除的结点没有子节点，则将父结点的相应孩子设置为nullptr
      - 如果有一个孩子，则将孩子放到父结点的相应位置
      - 如果有两个孩子
        - 将右子树放到被删除结点的位置，左子树中所有的值比根节点小，也比右子树中所有的值小，所以可以将左子树放到右子树最靠左的位置
        - 或者将左子树放到被删除结点的位置，将右子树放到左子树最靠右的位置
        - **这是最简单的删除方法，并不能保证树的高度平衡**

    - 递归

      - ```c++
        // 语法错误
        // delete后，不能访问root了，虽然root->left指向的位置还存在，但是不能用root找到这块区域了
        delete root;
        return root->left;
        
        // 应该是
        node*p = root->left;
        delete root;
        return p;
        ```
        
        
        

    - 迭代

      - 需要用两个指针，一个指针指向当前结点，一个指针指向它的父结点

      - 因为二叉搜索树有方向，所以不需要全部遍历，也就不需要栈了

      - 这里有个错误

        - ![Screenshot_20220306_200125_com.newskyer.draw1](https://gitee.com/hit_whr/pic_2.0/raw/main/Screenshot_20220306_200125_com.newskyer.draw1.jpg)

        - ```cpp
          void delete_node(node *pwd, node *pre, int key)
          {
              // 删除pwd需要知道pwd是pre的哪个儿子
              node *pos;
              // pwd是pre的右儿子
              if (key > pre->val)
              {
                  pos = pre->right;
              }
              // pwd是pre的左儿子
              else
              {
                  pos = pre->left;
              }
          
              // 需要判断pwd有无孩子
              // pwd无左右孩子
              if (!pwd->left && !pwd->right)
              {
                  pos = nullptr;
              }
              // 只有左子树
              else if (pwd->left && !pwd->right)
              {
                  pos = pwd->left;
              }
          }
          ```

        - 

        - ```cpp
          // 这里为了代码简洁，用了个骚操作
          // 指针的指针
          void delete_node(node *pwd, node *pre, int key)
          {
              // 删除pwd需要知道pwd是pre的哪个儿子
              node **pos;
              // pwd是pre的右儿子
              if (key > pre->val)
              {
                  pos = &(pre->right);
              }
              // pwd是pre的左儿子
              else
              {
                  pos = &(pre->left);
              }
          
              // 需要判断pwd有无孩子
              // pwd无左右孩子
              if (!pwd->left && !pwd->right)
              {
                  *pos = nullptr;
              }
              // 只有左子树
              else if (pwd->left && !pwd->right)
              {
                  *pos = pwd->left;
              }
          }
          ```

      - 还有个操作

        - 为了避免删除结点为根节点这个情况，在根节点之前又引入一个伪根节点，让操作保持一致
        - 同时规定根节点在伪根节点的左侧
        - 这样，就可以保证一直返回伪根节点的左孩子

    - 另一种解法

      - pre，cur只是找到结点
      - 找到后进行删除，同时判断pre是否为空（此时删除的是根节点）
      - 删除操作会返回删除该节点后的新节点
      - 相比于第一种迭代
        - 对逻辑进行了优化
        - 主要在于删除结点后返回这棵子树新的根结点
        - 这样，判断pwd是pre哪个孩子的问题就不需要出现在删除函数中
        - 函数的功能更加清晰

    - 更难的，平衡二叉树插入删除

      - 平衡二叉树是二叉搜索树，且任意结点左右子树的高度差不超过1，进而保证比较均衡的搜索效率
      - 插入
      - 删除


- 2022年3月5日下午，二叉树

  - 106，根据中序后序遍历结果还原一颗二叉树

    - 后序遍历的最后一个值确定根节点
    - 根节点对中序遍历进行划分，得到左右子树
    - 写了两个解法
      - 针对空间复杂度进行优化

  - 105，根据中序前序遍历结果还原一颗二叉树

  - 404，所有左叶子结点之和

    - 还是递归的当层单层处理逻辑问题

    - ```cpp
      class NewSolution
      {
      public:
          // 递归
          int sumOfLeftLeaves(TreeNode *root)
          {
              if (root == nullptr)
              {
                  return 0;
              }
              int res = 0;
              // 处理左子树
              if (root->left)
              {
                  // 左子树是叶子结点
                  if (root->left->left == nullptr && root->left->right == nullptr)
                  {
                      res += root->left->val;
                  }
                  // 递归处理左子树
                  else
                  {
                      res += sumOfLeftLeaves(root->left);
                  }
              }
              // 处理右子树
              // 右子树不需要考虑是不是叶子结点，直接处理
              res += sumOfLeftLeaves(root->right);
              return res;
          }
      };
      ```

    - 这个代码的问题是，处理了两层

    - 因为虽然用`res += sumOfLeftLeaves(root->left);`对左子树进行了递归，但还是判断了左子树是否为空，这是没有必要的。因为在第一部分就对根节点是否为空进行了判断。

    - 真正处理一层的应该这样

    - ```cpp
      class NewNewSolution
      {
      public:
          // 递归
          int sumOfLeftLeaves(TreeNode *root)
          {
              if (root == nullptr)
              {
                  return 0;
              }
              int res = 0;
              // 左子树
              res += sumOfLeftLeaves(root->left);
              // 右子树
              res += sumOfLeftLeaves(root->right);
              // 根节点
              if (root->left && root->left->left == nullptr && root->left->right == nullptr)
              {
                  res += root->left->val;
              }
              return res;
          }
      };
      ```

  - 513，获得左下角的结点

    - 左下角的结点是指深度最深且最靠左的结点
    - 层序遍历（队列+迭代）中，要记录某一层结点的个数，只需要在遍历之前记录队列长度即可
    - 递归实现（比较不好理解）

- 2022年3月5日晚上
  - 222，求完全二叉树的结点个数
    - 纯遍历
      - 没用到完全二叉树的性质
    - 性质
      - 完全二叉树的某个子树，至少是一个完全二叉树，也可能是一个满二叉树
      - 如果是满二叉树，通过深度直接计算结点数
    - 判断完全二叉树是不是满二叉树
      - 看最左侧儿子和最右侧儿子的深度是否相同

  - 104二叉树的最大深度，111二叉树的最小深度
    - 从层序遍历的角度来看，最大深度需要遍历所有层，最小深度遍历到叶子结点即可
    - 从递归的角度来看，最小深度的特殊点在于，如果为叶子结点，应该返回1；如果不是叶子结点，需要检查左右孩子是否为空，**为空时，不能处理。**

- 2022年3月6日上午

  - **110，平衡二叉树**

    - 二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。
      - 根节点的深度为1
      - 要得到某个结点的深度，采用深度优先遍历或者利用层序遍历的层数
      - 因为已知根节点的深度，所以采用前序遍历
    - 二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。
      - 树的高度即为根节点的高度*
        - 叶子结点的高度为1，所以要得到树的高度即根节点的高度，应该采用后序遍历
    - ![image-20220306233522334](https://gitee.com/hit_whr/pic_2.0/raw/main/image-20220306233522334.png)
    - 104，二叉树结点的最大深度
      - 最大深度必须是某个叶子结点的深度
      - 根节点的深度为1
      - 递归
        - 前序遍历
          - 先处理根节点
            - 用传入的可能值来更新max
          - 再递归处理左右孩子
            - 此时传入的可能值为根节点的可能值+1
          - 递归的结束条件为
            - 结点为空
        - 后序遍历
          - 叶子结点的高度为1，所以可以从下往上处理（后序遍历），获得结点的高度，直到根节点的高度
          - 后序遍历是先处理左右孩子再处理根节点
          - 本质上是获得左右子树的最大高度，然后获得树的最大高度，而树的最大高度即为根节点的高度，即为最大深度
          - 所以实际上是获得高度
      - 迭代
        - 层序遍历
    - 判定
      - 平衡二叉树不仅要保证根节点的左右子树高度差不超过1，还要保证左右孩子也满足这个条件，也就是所有结点的左右子树高度差都不超过1.
    - 递归
      - 因为是高度，结合上面的经验，采用后序遍历
      - 对于左子树
        - 如果是二叉平衡树需要返回它的高度，因为根节点需要使用这个值
        - 如果不是，需要返回一个标记，因为左子树不是二叉平衡树了，则没必要检查右子树了，也没必要检查根节点了。必然不是二叉平衡树
      - 对于右子树
        - 同样如此
      - 只有左右子树都是二叉平衡树时，才有必要检查根节点
      - 代码中，递归-后序遍历给出了两种方案
        - 第一种方案的缺点是有两层递归，内层递归用后序遍历求高度，但由于只求了高度，没有标记，所以外层递归先判断左右子树的高度差，然后又递归的解决左右子树。
        - 第二种方案进行了改进，有了标记，如果某棵子树不是二叉平衡树，则马上会终止递归。
    - 迭代
      - 先用迭代实现求高度（实际上是一个相对值，子树的高度都只是相对当前父结点）
      - 然后再开始外层递归，也就是先比较左右子树的高度差，然后再处理左右子树
      - 发现效率很低
      - ![image-20220306101901295](https://gitee.com/hit_whr/pic_2.0/raw/main/image-20220306101901295.png)
      - 原因
        - 没有很好的模拟回溯的过程，所以迭代法有很多重复的计算。
          - 很多结点被遍历了多次
        - 虽然理论上所有的递归都可以用迭代来实现，但是有的场景难度可能比较大
        - **回溯法其实就是递归，但是很少人用迭代的方式去实现回溯算法！**
        - 因为对于回溯算法已经是非常复杂的递归了，如果在用迭代的话，就是自己给自己找麻烦，效率也并不一定高。

  - 257，从根节点到所有叶子结点的路径

    - 递归
      - 为了记录历史信息，显然需要先访问根节点，所以采用前序遍历
      - 结束条件
        - 碰到叶子结点，此时只需要将历史int整合成string，放入结果中即可
      - 递归处理
        - 左右孩子
      - 参数
        - 这里有两个处理
          - 我是将参数定义为结点和历史信息（按值传递），然后用一个全局变量来放结果
            - 这样的好处是，不需要再递归后手动回溯
            - 坏处是，空间复杂度比较大，因为每一层递归都会生成新的历史信息
          - 还可以将历史信息按照引用来传递
            - 需要在递归后回溯
              - **回溯和递归是一一对应的，有一个递归，就要有一个回溯**
              - **回溯要和递归永远在一起，世界上最遥远的距离是你在花括号里，而我在花括号外！**
            - 但空间复杂度比较低，因为只有一份历史信息
          - 效率对比
            - ![image-20220306161020975](https://gitee.com/hit_whr/pic_2.0/raw/main/image-20220306161020975.png)
    - 迭代
      - 实际上就是用栈来实现前序遍历
      - 中
        - 检查是不是叶子结点
      - 右
      - 左
      - 值得注意的是，这里不仅要存储结点，还要存储历史信息，所以需要定义一个结构体，栈中放结构体
      - 这样的话，空间复杂度与递归-按值传参差不多
  
- 2022年3月6日下午，二叉树

  - 112路径和
    - 这题和上面的所有路径基本上是一样的
    - 都采用前序遍历
    - 递归
      - 这里无论按值传递还是引用传递，空间复杂度都不会太大，因为不需要像所有路径一样记录历史信息，只需要记录targetSum
      - 中
        - 得到新的targetSum
        - 判断叶子结点和是否满足值条件
      - 左
        - 用新的targetSum开始递归
      - 右
        - 用新的targetSum开始递归
    - 迭代
      - 栈中存放结点和历史targetSum信息
      - 或者用两个栈，这两个栈的push、pop操作要保持一致
    - 引申
      - 递归什么时候需要返回值，什么是否不需要返回值
        - 如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（113.路径总和ii）
        - 如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （236. 二叉树的最近公共祖先）
        - 如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（本题的情况）
    
  - 113路径和找路径

    - 112只是判断路径的存在性，不需要遍历整棵树
    - 而本题是找到所有路径，且路径上结点和等于给定值，需要遍历整棵树
    - 递归
      - 按值传参
      - 引用传参
      - 效率对比
        - ![image-20220306160802831](https://gitee.com/hit_whr/pic_2.0/raw/main/image-20220306160802831.png)
    - 迭代
      - 所有路径差不多，只是加了对和的判断
      - 有bug

  - 654，根据数组构建最大二叉树

    - 最大二叉树的构建
      - 用数组中的最大值构建根节点
      - 用最大值左侧的子数组构建左子树，用最大值右侧的子数组构建右子树
      - 显然，这是递归定义
    - 题目给的参数是引用传参
    - 递归
      - 复制vector，空间复杂度比较大
      - 索引，时间和空间上的开销都比较小
    - **注意类似用数组构造二叉树的题目，每次分隔尽量不要定义新的数组，而是通过下标索引直接在原数组上操作，这样可以节约时间和空间上的开销。**

  - 101，判断二叉树是否轴对称

    - 所谓轴对称即镜像对称

      - 不仅要保证结构，还要保证结点值

    - 迭代

      - 两个栈

      - 同时执行相反的操作

      - 下面这个代码有点多余，因为初始值是相同的，做了很多不必要的工作

      - 而且有bug，可能出现left的left为空，但是right的right不为空的情况

      - ```cpp
        // 定义两个栈，栈的初始值相同
        // 同时执行相反的操作
        class Solution
        {
        public:
            bool isSymmetric(TreeNode *root)
            {
                if (root == nullptr)
                {
                    return true;
                }
                stack<node *> left, right;
                node *left_node, *right_node;
                left.push(root), right.push(root);
                while (!left.empty())
                {
                    left_node = left.top();
                    left.pop();
                    right_node = right.top();
                    right.pop();
                    // 检查结点值
                    if (left_node->val != right_node->val)
                    {
                        return false;
                    }
                    if (left_node->left)
                    {
                        if (right_node->right)
                        {
                            left.push(left_node->left);
                            right.push(right_node->right);
                        }
                        else
                        {
                            return false;
                        }
                    }
                    if (left_node->right)
                    {
                        if (right_node->left)
                        {
                            left.push(left_node->right);
                            right.push(right_node->left);
                        }
                        else
                        {
                            return false;
                        }
                    }
                }
                return true;
            }
        };
        ```

      - 

    - 递归

      - 一个重大错误，不能简单地递归进入左右子树，因为此时无法看到另一侧的内容
      - 吸取上面的教训，应该同时传入两个要比较的根节点作为参数
        - `因为我们要比较的是根节点的两个子树是否是相互翻转的，进而判断这个树是不是对称树，所以要比较的是两个树，参数自然也是左子树节点和右子树节点。`


  

- 2022年3月7日下午，二叉树

  - 108，根据有序数组构造平衡的BST

    - 因为是有序数组，所以可以通过不断均分来递归构造

      - 从数组中选取中间值作为根节点
      - 左子数组构建左子树，右子数组构建右子树

    - 平衡是指任意结点左右子树的高度差都不超过1

    - 递归

      - 引用传参+索引
      - 按值传参+复制

    - 迭代

      - 就是模拟递归的过程，需要在栈中存放结点，当时数组区间的左右边界
        - 对于栈，可以用三个栈，保持同步操作
        - 也可以用一个栈，栈中存放结构体

    - int越界

      - 在求两个整数的平均数时，如果这两个数a，b都是int能够表达的最大值，尽管int能表达结果c，但是结果c仍然不正确。因为（a+b)这个中间量越界

      - 应该写成（a-b)/2+b

      - ```cpp
        int a, b, c;
        a = INT_MAX, b = a;
        c = (a + b) / 2;
        cout << "a=" << a << " b=" << b << " c=" << c << endl;
        c = (a - b) / 2 + b;
        cout << "a=" << a << " b=" << b << " c=" << c << endl;
        
        a=2147483647 b=2147483647 c=-1
        a=2147483647 b=2147483647 c=2147483647
        ```

        

  - 538，二叉搜索树转累加树

    - 累加树满足：结点的新值=不小于该结点旧值的结点值之和，也要对该结点的旧值求和
    - 观察示例，需要采用右中左的遍历顺序
      - ![image-20220307160403454](https://gitee.com/hit_whr/pic_2.0/raw/main/image-20220307160403454.png)
      - 因为最右结点不存在比他的值，取自身值即可，新值放到变量pre中
      - 中结点等于自身值+pre，新值放到变量pre中
      - 左结点也是如此
    - 换一个考虑角度
      - 为了实现找到不小于的值，必须进行降序排序
      - 因为是二叉搜索树，所以应该右中左遍历
      - 同时要记录上一个结点（即排序中相邻节点）的新值
    - 递归
      - 需要用一个值来记录上次处理过（即排序中相邻结点）的新值
    - 迭代-栈
      - 比较不好理解，需要用到中序遍历的知识
        - 中序遍历，左中右
          - 如果指针不为空，则指针入栈，继续指向左儿子
          - 如果指针为空，栈顶为指针的父结点，弹出，此时为中，**处理**
            - 然后指向右儿子
          - 当指针为空且栈为空（找不到该节点的父结点）时，结束
      - 本题，右中左
        - 处理就是修改中结点的val

  - 669

    - 

  - 1

  - 题目

- 2022年3月7日晚上，回溯（组合问题）

  - 回溯

    - 回溯的本质

      - 回溯的本质是穷举
      - 遍历的空间通过剪枝来缩小

    - 回溯解决的问题可以抽象为一棵树

      - 所以有了剪枝这个说法

    - 回溯的格式

      - 因为回溯函数就是递归函数，所以就是递归的格式

      - ```cpp
        void func(参数)
        {
            // 终止条件
            if(){
                returnl
            }
            // 横向遍历
            for(){
                // 处理当前结点
                func()//递归，实际上是纵向遍历
                // 回溯
            }
        }
        ```

  - 77

    - 给定n和k，在1-n这n个数中选取k个，要求列出所有情况，数学上就是C(n,k)

    - ![image-20220307192338649](https://gitee.com/hit_whr/pic_2.0/raw/main/image-20220307192338649.png)

    - 选取一个值后，只需要从它后面一个值到n进行选择

      - 所以参数中应该有有两个参数来指明这个左闭右闭区间
      - 还需要一个参数来记录k（不变量）

    - 根据上面的模板

      - ```cpp
        void func(int left, int right, int k)
        {
            // 个数满足，终止
            if (path.size() == k)
            {
                res.push_back(path);
                return;
            }
            for (int i = left; i <= right; i++)
            {
                // 处理本结点
                // 就是放到路径中
                path.push_back(i);
                // 递归
                // 此时因为选取了i，所以后面只能从i+1开始
                func(i + 1, right, k);
                // 回溯
                path.pop_back();
            }
        }
        ```

      - 然后用剪枝来优化

        - 其实就是left到right的元素个数应该能够满足需要，如果太少了，就没必要再递归下去了

        - ```cpp
          void func(int left, int right, int k)
          {
              if (path.size() == k)
              {
                  res.push_back(path);
                  return;
              }
              // 如果后面数组的总数都不能满足要求，没必要再递归了
              // 还有的元素个数=right-i+1
              // 还需要的元素个数=k-path.size()
              // right-i+1>=k-path.size()即i<=right+1-k+path.size()
              for (int i = left; i <= right + 1 - k + path.size(); i++)
              {
                  // 处理本结点
                  path.push_back(i);
                  // 递归
                  // 此时因为选取了i，所以后面只能从i+1开始
                  func(i + 1, right, k);
                  // 回溯
                  path.pop_back();
              }
          }
          ```

  - 216，在1-9中不重复的选取k个数，使之和为n，显然k<=9

    - 参数
      - 左右边界
      - n，k，path的和
    - 当path中元素个数为k时，开始检查和，满足，放入；不满足，不放入。但都要退出递归。
    - 出现的错误
      - ![image-20220307194004622](https://gitee.com/hit_whr/pic_2.0/raw/main/image-20220307194004622.png)
      - 1、没有考虑最多k个数这个条件，只考虑了和满足条件
      - 2、没有在递归函数中修改左边界，所以引入了重复值
    - 剪枝
      - 如果当前的sum已经大于n了，没必要再找了
      - 如果后面的结点数不能满足需要了，也没必要再找了

  - 17，给定一个只有2-9的字符串，将数字按照九键输入法映射到字母上

    - **上面几个组合，在不同深度上，都是对同一集合进行操作，所以为了避免重复，引入两个参数，确定边界**
    - 而这个题，每到一个深度，都会出现一个新的集合（不同数字对应不同字母集，本身没有关联），所以不需要确定边界
    - 只需要知道当前的深度（是第几个数字）
    - 删除string中的某个字符
      - string.erase(iterator)
    - 删除string末尾的字符
      - `string.erase(string.end()-1);`
    - 这道题无法剪枝，因为是考虑所有情况，没有限制条件

    

  - 

    - 1

  - 题目

- 1

- 时间



 

# todo

- 513
- 根据数组构造一棵高度平衡的二叉搜索树



- 实现堆
- 递归
  - 参数+返回值
  - 终止条件
  - 单层处理逻辑
- 一个可视化、自动生成最短路的pro
- 再看最小绝对差和众数

