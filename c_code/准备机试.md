# 记录

- 2022年2月22日下午和晚上，算法-栈与队列

- 2022年2月23日晚上，算法-栈与队列
  
  - **C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树**，所以map、set的增删操作时间时间复杂度是logn，注意我这里没有说unordered_map、unordered_set，unordered_map、unordered_map底层实现是哈希表。
  
- 2022年2月24日下午晚上，二叉树DFS&BFS
  
  - 在处理类似于头结点、max初始化时，如何更加简洁的书写
    - 515,116
  
- 2022年3月2日上午，二叉树

  - 617

    - 考虑树的题目，不需要考虑很多结点，而是考虑到所有情况。结点数量选一个父子节点即可（递归的思路）

  - 700

    - 二叉搜索树
    - 注意二叉搜索树的性质

  - 98

    - 判断是不是二叉搜索树

    - 这里出现了定义和性质的混淆

    - 性质是

      - 根节点的值大于左儿子的值，小于右儿子的值

      - 但这个不能用来判断是不是二叉搜索树

      - 例如

      - ```bash
           5
         4	6
           3  7
        ```

      - 满足性质，不是二叉搜索树（3小于5）

    - 定义是

      - 比根节点小的值都进入左侧，比根节点大的值都进入右侧
      - 左右子树也满足这两个条件

    - 二叉搜索树中不能有相等的元素

    - 采用中序遍历

      - 可以是递归+数组
      - 也可以迭代（比较不好理解）

  - 530

    - 最小差值

    - 一个语言bug

    - ​    // error:node *p = root, *pre;

      ​    // 因为pre指针没有初始化，可能指向一个危险的区域

      ​    // 实际上通过debug发现该指针确实指向一个低地址0x0018

      ​    node *p = *root*, *pre = nullptr;

  - 501 + 一个求众数的代码

    - 可以先遍历一次，更新map的内容，然后将key-value作为pair放到vector中，对vector排序
      - 找到所有频率等于maxCount的
    - 可以先排序
      - 然后遍历一次
      - 设置count和maxCount
    - 可以先排序
      - 遍历一次，找到maxCount
      - 然后再遍历一次，找到频率和maxCount相等的

  - 236，一般二叉树找祖先

    - 典型的递归
      - 可以判断pq是在同侧还是异侧
        - 这是一个自上而下的顺序
      - 也可以用后序遍历
        - 因为找祖先是一个自下而上的过程，二叉树不能自下而上，只能自上而下
        - 后序遍历可以起到回溯的效果

  - 235，二叉搜索树找祖先

    - 比一般二叉树找祖先容易，因为BST自带大小比较
    - 递归
      - 利用二叉搜索树自带的方向性
    - 迭代
      - 同样如此

  - 701，BST插入

    - 很简单，但是能否用遍历的套路来解决这个问题呢？
      - 递归
      - 迭代
        - 找到插入点后，需要知道插入点的父结点
        - 所以还需要一个指针记录父结点
    - 一般引申的问题是，插入后如何保持BST的平衡

  - 450，BST删除

    - 删除的策略

      - 删除节点需要知道被删除结点及其父结点
      - 如果被删除的结点没有子节点，则将父结点的相应孩子设置为nullptr
      - 如果有一个孩子，则将孩子放到父结点的相应位置
      - 如果有两个孩子
        - 将右子树放到被删除结点的位置，左子树中所有的值比根节点小，也比右子树中所有的值小，所以可以将左子树放到右子树最靠左的位置
        - 或者将左子树放到被删除结点的位置，将右子树放到左子树最靠右的位置
        - **这是最简单的删除方法，并不能保证树的高度平衡**

    - 递归

      - ```c++
        // 语法错误
        // delete后，不能访问root了，虽然root->left指向的位置还存在，但是不能用root找到这块区域了
        delete root;
        return root->left;
        
        // 应该是
        node*p = root->left;
        delete root;
        return p;
        ```
        
        
        

    - 迭代

      - 需要用两个指针，一个指针指向当前结点，一个指针指向它的父结点

      - 因为二叉搜索树有方向，所以不需要全部遍历，也就不需要栈了

      - 这里有个错误

        - ![Screenshot_20220306_200125_com.newskyer.draw1](https://gitee.com/hit_whr/pic_2.0/raw/main/Screenshot_20220306_200125_com.newskyer.draw1.jpg)

        - ```cpp
          void delete_node(node *pwd, node *pre, int key)
          {
              // 删除pwd需要知道pwd是pre的哪个儿子
              node *pos;
              // pwd是pre的右儿子
              if (key > pre->val)
              {
                  pos = pre->right;
              }
              // pwd是pre的左儿子
              else
              {
                  pos = pre->left;
              }
          
              // 需要判断pwd有无孩子
              // pwd无左右孩子
              if (!pwd->left && !pwd->right)
              {
                  pos = nullptr;
              }
              // 只有左子树
              else if (pwd->left && !pwd->right)
              {
                  pos = pwd->left;
              }
          }
          ```

        - 

        - ```cpp
          // 这里为了代码简洁，用了个骚操作
          // 指针的指针
          void delete_node(node *pwd, node *pre, int key)
          {
              // 删除pwd需要知道pwd是pre的哪个儿子
              node **pos;
              // pwd是pre的右儿子
              if (key > pre->val)
              {
                  pos = &(pre->right);
              }
              // pwd是pre的左儿子
              else
              {
                  pos = &(pre->left);
              }
          
              // 需要判断pwd有无孩子
              // pwd无左右孩子
              if (!pwd->left && !pwd->right)
              {
                  *pos = nullptr;
              }
              // 只有左子树
              else if (pwd->left && !pwd->right)
              {
                  *pos = pwd->left;
              }
          }
          ```

      - 还有个操作

        - 为了避免删除结点为根节点这个情况，在根节点之前又引入一个伪根节点，让操作保持一致
        - 同时规定根节点在伪根节点的左侧
        - 这样，就可以保证一直返回伪根节点的左孩子

    - 另一种解法

      - pre，cur只是找到结点
      - 找到后进行删除，同时判断pre是否为空（此时删除的是根节点）
      - 删除操作会返回删除该节点后的新节点
      - 相比于第一种迭代
        - 对逻辑进行了优化
        - 主要在于删除结点后返回这棵子树新的根结点
        - 这样，判断pwd是pre哪个孩子的问题就不需要出现在删除函数中
        - 函数的功能更加清晰

    - 更难的，平衡二叉树插入删除

      - 平衡二叉树是二叉搜索树，且任意结点左右子树的高度差不超过1，进而保证比较均衡的搜索效率
      - 插入
      - 删除


- 2022年3月5日下午，二叉树

  - 106，根据中序后序遍历结果还原一颗二叉树

    - 后序遍历的最后一个值确定根节点
    - 根节点对中序遍历进行划分，得到左右子树
    - 写了两个解法
      - 针对空间复杂度进行优化

  - 105，根据中序前序遍历结果还原一颗二叉树

  - 404，所有左叶子结点之和

    - 还是递归的当层单层处理逻辑问题

    - ```cpp
      class NewSolution
      {
      public:
          // 递归
          int sumOfLeftLeaves(TreeNode *root)
          {
              if (root == nullptr)
              {
                  return 0;
              }
              int res = 0;
              // 处理左子树
              if (root->left)
              {
                  // 左子树是叶子结点
                  if (root->left->left == nullptr && root->left->right == nullptr)
                  {
                      res += root->left->val;
                  }
                  // 递归处理左子树
                  else
                  {
                      res += sumOfLeftLeaves(root->left);
                  }
              }
              // 处理右子树
              // 右子树不需要考虑是不是叶子结点，直接处理
              res += sumOfLeftLeaves(root->right);
              return res;
          }
      };
      ```

    - 这个代码的问题是，处理了两层

    - 因为虽然用`res += sumOfLeftLeaves(root->left);`对左子树进行了递归，但还是判断了左子树是否为空，这是没有必要的。因为在第一部分就对根节点是否为空进行了判断。

    - 真正处理一层的应该这样

    - ```cpp
      class NewNewSolution
      {
      public:
          // 递归
          int sumOfLeftLeaves(TreeNode *root)
          {
              if (root == nullptr)
              {
                  return 0;
              }
              int res = 0;
              // 左子树
              res += sumOfLeftLeaves(root->left);
              // 右子树
              res += sumOfLeftLeaves(root->right);
              // 根节点
              if (root->left && root->left->left == nullptr && root->left->right == nullptr)
              {
                  res += root->left->val;
              }
              return res;
          }
      };
      ```

  - 513，获得左下角的结点

    - 左下角的结点是指深度最深且最靠左的结点
    - 层序遍历（队列+迭代）中，要记录某一层结点的个数，只需要在遍历之前记录队列长度即可
    - 递归实现（比较不好理解）

- 2022年3月5日晚上
  - 222，求完全二叉树的结点个数
    - 纯遍历
      - 没用到完全二叉树的性质
    - 性质
      - 完全二叉树的某个子树，至少是一个完全二叉树，也可能是一个满二叉树
      - 如果是满二叉树，通过深度直接计算结点数
    - 判断完全二叉树是不是满二叉树
      - 看最左侧儿子和最右侧儿子的深度是否相同

  - 104二叉树的最大深度，111二叉树的最小深度
    - 从层序遍历的角度来看，最大深度需要遍历所有层，最小深度遍历到叶子结点即可
    - 从递归的角度来看，最小深度的特殊点在于，如果为叶子结点，应该返回1；如果不是叶子结点，需要检查左右孩子是否为空，**为空时，不能处理。**

- 2022年3月6日上午

  - **110，平衡二叉树**

    - 二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。
      - 根节点的深度为1
      - 要得到某个结点的深度，采用深度优先遍历或者利用层序遍历的层数
      - 因为已知根节点的深度，所以采用前序遍历
    - 二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。
      - 树的高度即为根节点的高度*
        - 叶子结点的高度为1，所以要得到树的高度即根节点的高度，应该采用后序遍历
    - ![image-20220306233522334](https://gitee.com/hit_whr/pic_2.0/raw/main/image-20220306233522334.png)
    - 104，二叉树结点的最大深度
      - 最大深度必须是某个叶子结点的深度
      - 根节点的深度为1
      - 递归
        - 前序遍历
          - 先处理根节点
            - 用传入的可能值来更新max
          - 再递归处理左右孩子
            - 此时传入的可能值为根节点的可能值+1
          - 递归的结束条件为
            - 结点为空
        - 后序遍历
          - 叶子结点的高度为1，所以可以从下往上处理（后序遍历），获得结点的高度，直到根节点的高度
          - 后序遍历是先处理左右孩子再处理根节点
          - 本质上是获得左右子树的最大高度，然后获得树的最大高度，而树的最大高度即为根节点的高度，即为最大深度
          - 所以实际上是获得高度
      - 迭代
        - 层序遍历
    - 判定
      - 平衡二叉树不仅要保证根节点的左右子树高度差不超过1，还要保证左右孩子也满足这个条件，也就是所有结点的左右子树高度差都不超过1.
    - 递归
      - 因为是高度，结合上面的经验，采用后序遍历
      - 对于左子树
        - 如果是二叉平衡树需要返回它的高度，因为根节点需要使用这个值
        - 如果不是，需要返回一个标记，因为左子树不是二叉平衡树了，则没必要检查右子树了，也没必要检查根节点了。必然不是二叉平衡树
      - 对于右子树
        - 同样如此
      - 只有左右子树都是二叉平衡树时，才有必要检查根节点
      - 代码中，递归-后序遍历给出了两种方案
        - 第一种方案的缺点是有两层递归，内层递归用后序遍历求高度，但由于只求了高度，没有标记，所以外层递归先判断左右子树的高度差，然后又递归的解决左右子树。
        - 第二种方案进行了改进，有了标记，如果某棵子树不是二叉平衡树，则马上会终止递归。
    - 迭代
      - 先用迭代实现求高度（实际上是一个相对值，子树的高度都只是相对当前父结点）
      - 然后再开始外层递归，也就是先比较左右子树的高度差，然后再处理左右子树
      - 发现效率很低
      - ![image-20220306101901295](https://gitee.com/hit_whr/pic_2.0/raw/main/image-20220306101901295.png)
      - 原因
        - 没有很好的模拟回溯的过程，所以迭代法有很多重复的计算。
          - 很多结点被遍历了多次
        - 虽然理论上所有的递归都可以用迭代来实现，但是有的场景难度可能比较大
        - **回溯法其实就是递归，但是很少人用迭代的方式去实现回溯算法！**
        - 因为对于回溯算法已经是非常复杂的递归了，如果在用迭代的话，就是自己给自己找麻烦，效率也并不一定高。

  - 257，从根节点到所有叶子结点的路径

    - 递归
      - 为了记录历史信息，显然需要先访问根节点，所以采用前序遍历
      - 结束条件
        - 碰到叶子结点，此时只需要将历史int整合成string，放入结果中即可
      - 递归处理
        - 左右孩子
      - 参数
        - 这里有两个处理
          - 我是将参数定义为结点和历史信息（按值传递），然后用一个全局变量来放结果
            - 这样的好处是，不需要再递归后手动回溯
            - 坏处是，空间复杂度比较大，因为每一层递归都会生成新的历史信息
          - 还可以将历史信息按照引用来传递
            - 需要在递归后回溯
              - **回溯和递归是一一对应的，有一个递归，就要有一个回溯**
              - **回溯要和递归永远在一起，世界上最遥远的距离是你在花括号里，而我在花括号外！**
            - 但空间复杂度比较低，因为只有一份历史信息
          - 效率对比
            - ![image-20220306161020975](https://gitee.com/hit_whr/pic_2.0/raw/main/image-20220306161020975.png)
    - 迭代
      - 实际上就是用栈来实现前序遍历
      - 中
        - 检查是不是叶子结点
      - 右
      - 左
      - 值得注意的是，这里不仅要存储结点，还要存储历史信息，所以需要定义一个结构体，栈中放结构体
      - 这样的话，空间复杂度与递归-按值传参差不多
  
- 2022年3月6日下午，二叉树

  - 112路径和
    - 这题和上面的所有路径基本上是一样的
    - 都采用前序遍历
    - 递归
      - 这里无论按值传递还是引用传递，空间复杂度都不会太大，因为不需要像所有路径一样记录历史信息，只需要记录targetSum
      - 中
        - 得到新的targetSum
        - 判断叶子结点和是否满足值条件
      - 左
        - 用新的targetSum开始递归
      - 右
        - 用新的targetSum开始递归
    - 迭代
      - 栈中存放结点和历史targetSum信息
      - 或者用两个栈，这两个栈的push、pop操作要保持一致
    - 引申
      - 递归什么时候需要返回值，什么是否不需要返回值
        - 如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（113.路径总和ii）
        - 如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （236. 二叉树的最近公共祖先）
        - 如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（本题的情况）
    
  - 113路径和找路径

    - 112只是判断路径的存在性，不需要遍历整棵树
    - 而本题是找到所有路径，且路径上结点和等于给定值，需要遍历整棵树
    - 递归
      - 按值传参
      - 引用传参
      - 效率对比
        - ![image-20220306160802831](https://gitee.com/hit_whr/pic_2.0/raw/main/image-20220306160802831.png)
    - 迭代
      - 所有路径差不多，只是加了对和的判断
      - 有bug

  - 654，根据数组构建最大二叉树

    - 最大二叉树的构建
      - 用数组中的最大值构建根节点
      - 用最大值左侧的子数组构建左子树，用最大值右侧的子数组构建右子树
      - 显然，这是递归定义
    - 题目给的参数是引用传参
    - 递归
      - 复制vector，空间复杂度比较大
      - 索引，时间和空间上的开销都比较小
    - **注意类似用数组构造二叉树的题目，每次分隔尽量不要定义新的数组，而是通过下标索引直接在原数组上操作，这样可以节约时间和空间上的开销。**

  - 101，判断二叉树是否轴对称

    - 所谓轴对称即镜像对称

      - 不仅要保证结构，还要保证结点值

    - 迭代

      - 两个栈

      - 同时执行相反的操作

      - 下面这个代码有点多余，因为初始值是相同的，做了很多不必要的工作

      - 而且有bug，可能出现left的left为空，但是right的right不为空的情况

      - ```cpp
        // 定义两个栈，栈的初始值相同
        // 同时执行相反的操作
        class Solution
        {
        public:
            bool isSymmetric(TreeNode *root)
            {
                if (root == nullptr)
                {
                    return true;
                }
                stack<node *> left, right;
                node *left_node, *right_node;
                left.push(root), right.push(root);
                while (!left.empty())
                {
                    left_node = left.top();
                    left.pop();
                    right_node = right.top();
                    right.pop();
                    // 检查结点值
                    if (left_node->val != right_node->val)
                    {
                        return false;
                    }
                    if (left_node->left)
                    {
                        if (right_node->right)
                        {
                            left.push(left_node->left);
                            right.push(right_node->right);
                        }
                        else
                        {
                            return false;
                        }
                    }
                    if (left_node->right)
                    {
                        if (right_node->left)
                        {
                            left.push(left_node->right);
                            right.push(right_node->left);
                        }
                        else
                        {
                            return false;
                        }
                    }
                }
                return true;
            }
        };
        ```

      - 

    - 递归

      - 一个重大错误，不能简单地递归进入左右子树，因为此时无法看到另一侧的内容
      - 吸取上面的教训，应该同时传入两个要比较的根节点作为参数
        - `因为我们要比较的是根节点的两个子树是否是相互翻转的，进而判断这个树是不是对称树，所以要比较的是两个树，参数自然也是左子树节点和右子树节点。`




- 2022年3月7日下午，二叉树

  - 108，根据有序数组构造平衡的BST

    - 因为是有序数组，所以可以通过不断均分来递归构造

      - 从数组中选取中间值作为根节点
      - 左子数组构建左子树，右子数组构建右子树

    - 平衡是指任意结点左右子树的高度差都不超过1

    - 递归

      - 引用传参+索引
      - 按值传参+复制

    - 迭代

      - 就是模拟递归的过程，需要在栈中存放结点，当时数组区间的左右边界
        - 对于栈，可以用三个栈，保持同步操作
        - 也可以用一个栈，栈中存放结构体

    - int越界

      - 在求两个整数的平均数时，如果这两个数a，b都是int能够表达的最大值，尽管int能表达结果c，但是结果c仍然不正确。因为（a+b)这个中间量越界

      - 应该写成（a-b)/2+b

      - ```cpp
        int a, b, c;
        a = INT_MAX, b = a;
        c = (a + b) / 2;
        cout << "a=" << a << " b=" << b << " c=" << c << endl;
        c = (a - b) / 2 + b;
        cout << "a=" << a << " b=" << b << " c=" << c << endl;
        
        a=2147483647 b=2147483647 c=-1
        a=2147483647 b=2147483647 c=2147483647
        ```

        

  - 538，二叉搜索树转累加树

    - 累加树满足：结点的新值=不小于该结点旧值的结点值之和，也要对该结点的旧值求和
    - 观察示例，需要采用右中左的遍历顺序
      - ![image-20220307160403454](https://gitee.com/hit_whr/pic_2.0/raw/main/image-20220307160403454.png)
      - 因为最右结点不存在比他的值，取自身值即可，新值放到变量pre中
      - 中结点等于自身值+pre，新值放到变量pre中
      - 左结点也是如此
    - 换一个考虑角度
      - 为了实现找到不小于的值，必须进行降序排序
      - 因为是二叉搜索树，所以应该右中左遍历
      - 同时要记录上一个结点（即排序中相邻节点）的新值
    - 递归
      - 需要用一个值来记录上次处理过（即排序中相邻结点）的新值
    - 迭代-栈
      - 比较不好理解，需要用到中序遍历的知识
        - 中序遍历，左中右
          - 如果指针不为空，则指针入栈，继续指向左儿子
          - 如果指针为空，栈顶为指针的父结点，弹出，此时为中，**处理**
            - 然后指向右儿子
          - 当指针为空且栈为空（找不到该节点的父结点）时，结束
      - 本题，右中左
        - 处理就是修改中结点的val

  - 669

    - 

  - 1

  - 题目

- 2022年3月7日晚上，回溯（组合问题）

  - 回溯

    - 回溯的本质

      - 回溯的本质是穷举
      - 遍历的空间通过剪枝来缩小

    - 回溯解决的问题可以抽象为一棵树

      - 所以有了剪枝这个说法

    - 回溯的格式

      - 因为回溯函数就是递归函数，所以就是递归的格式

      - ```cpp
        void func(参数)
        {
            // 终止条件
            if(){
                returnl
            }
            // 横向遍历
            for(){
                // 处理当前结点
                func()//递归，实际上是纵向遍历
                // 回溯
            }
        }
        ```

  - 77

    - 给定n和k，在1-n这n个数中选取k个，要求列出所有情况，数学上就是C(n,k)

    - ![image-20220307192338649](https://gitee.com/hit_whr/pic_2.0/raw/main/image-20220307192338649.png)

    - 选取一个值后，只需要从它后面一个值到n进行选择

      - 所以参数中应该有有两个参数来指明这个左闭右闭区间
      - 还需要一个参数来记录k（不变量）

    - 根据上面的模板

      - ```cpp
        void func(int left, int right, int k)
        {
            // 个数满足，终止
            if (path.size() == k)
            {
                res.push_back(path);
                return;
            }
            for (int i = left; i <= right; i++)
            {
                // 处理本结点
                // 就是放到路径中
                path.push_back(i);
                // 递归
                // 此时因为选取了i，所以后面只能从i+1开始
                func(i + 1, right, k);
                // 回溯
                path.pop_back();
            }
        }
        ```

      - 然后用剪枝来优化

        - 其实就是left到right的元素个数应该能够满足需要，如果太少了，就没必要再递归下去了

        - ```cpp
          void func(int left, int right, int k)
          {
              if (path.size() == k)
              {
                  res.push_back(path);
                  return;
              }
              // 如果后面数组的总数都不能满足要求，没必要再递归了
              // 还有的元素个数=right-i+1
              // 还需要的元素个数=k-path.size()
              // right-i+1>=k-path.size()即i<=right+1-k+path.size()
              for (int i = left; i <= right + 1 - k + path.size(); i++)
              {
                  // 处理本结点
                  path.push_back(i);
                  // 递归
                  // 此时因为选取了i，所以后面只能从i+1开始
                  func(i + 1, right, k);
                  // 回溯
                  path.pop_back();
              }
          }
          ```

  - 216，在1-9中不重复的选取k个数，使之和为n，显然k<=9

    - 参数
      - 左右边界
      - n，k，path的和
    - 当path中元素个数为k时，开始检查和，满足，放入；不满足，不放入。但都要退出递归。
    - 出现的错误
      - ![image-20220307194004622](https://gitee.com/hit_whr/pic_2.0/raw/main/image-20220307194004622.png)
      - 1、没有考虑最多k个数这个条件，只考虑了和满足条件
      - 2、没有在递归函数中修改左边界，所以引入了重复值
    - 剪枝
      - 如果当前的sum已经大于n了，没必要再找了
      - 如果后面的结点数不能满足需要了，也没必要再找了

  - 17，给定一个只有2-9的字符串，将数字按照九键输入法映射到字母上

    - **上面几个组合，在不同深度上，都是对同一集合进行操作，所以为了避免重复，引入两个参数，确定边界**

    - 而这个题，每到一个深度，都会出现一个新的集合（不同数字对应不同字母集，本身没有关联），所以不需要确定边界

    - 只需要知道当前的深度（是第几个数字）

    - 删除string中的某个字符

      - string.erase(iterator)

    - 删除string末尾的字符

      - `string.erase(string.end()-1);`

      - 还有个更简单的做法

        - 因为string也是vector

        - ```cpp
          string a = "abc"; // abc
          a.erase(a.end() - 1);
          cout << a << endl; // ab
          a.push_back('s');
          cout << a << endl; // abs
          a.pop_back();
          cout << a << endl; // ab
          ```

    - 这道题无法剪枝，因为是考虑所有情况，没有限制条件

  - 39，给一个无重复元素的数组c，目标和t。从c中选任意多个元素，且这些元素可以重复，使他们的和为t

    - 这个题和之前又有了变化
      - 相比于C(n,k)
        - 没有元素个数限制
        - 没有重复的限制
        - 第一层用了c，下面还可以用c，但是第一层其他节点不能还是从c开始
        - 终止条件只是和超过了t

    - 因为是组合（1,2和2,1是一样的），所以从数组起点的角度来说，同一层的遍历，不能总是从0开始
    - 因为可以重复，所以可以还是从left开始（1,1,2）
      - 而C(n,k)不能重复，所以只能从left+1开始
    - 剪枝
      - 如果c是有序数组，当sum超过t时，后面的就都不需要处理了

  - 

  - 题目

- 40

  - 给一个可能有重复元素的数组c，目标和t

    从c中选任意多个元素，这些元素在c中是可以重复的，但每个元素只能在结果集合中出现一次，使他们的和为t

    也就是说，c中本身可以有重复元素，但元素不能被重复选

    因为是组合，不能回头；因为不能重复选，不能选自己，所以左边界+1

  - 先说错误的解法

    - ```cpp
      void func(vector<int> &candidates, int left, int right, int target, int sum)
      {
          if (target == sum)
          {
              res.push_back(path);
              return;
          }
          else if (sum > target)
          {
              return;
          }
      
          for (int i = left; i < right; i++)
          {
              // 处理当前结点
              path.push_back(candidates[i]);
              sum += candidates[i];
              // 递归
              func(candidates, i + 1, right, target, sum);
              // 回溯
              sum -= candidates[i];
              path.pop_back();
          }
      }
      ```

    - 为什么错呢？

    - 这个纵向遍历是对的，没有回头，没有选自己

    - 但是横向遍历不对，比如数据为1,2,3,1

      - 横向遍历先得到1,2,3，然后2,3,1也可以了。

    - 所以在横向遍历中不能出现重复元素，在纵向遍历中不能回头，不能选自己

  - 例子

    - 因为有重复元素所以必须先排序比如这个

      [10, 1, 2, 7, 6, 1, 5]

      [[1,2,5],[1,7],[1,6,1],[2,6],[2,1,5],[7,1]]

      [1,1,2,5,6,7,10]

      这个难点就在于重复元素有时可以同时出现(1,1,6)，有时又不想让它们同时出现(1,2,5和2,1,5)

      

      先排序

      对于重复元素

      针对第一种情况，在递归里面可以同时出现，只要不是自己、不回头就行

      - 不回头就是说，取过的元素不被重复取，也就是保证结果集合中不出现重复的（因为集合是无序的，所以1,2和2,1一样）

      针对第二种情况，排序后，在同一层里面不应该出现重复元素

  - 另一个解释

    - 都知道组合问题可以抽象为树形结构，那么“使用过”在这个树形结构上是有两个维度的，一个维度是同一树枝上使用过，一个维度是同一树层上使用过。**没有理解这两个层面上的“使用过” 是造成大家没有彻底理解去重的根本原因。**

      那么问题来了，我们是要同一树层上使用过，还是同一树枝上使用过呢？

      回看一下题目，元素在同一个组合内是可以重复的，怎么重复都没事，但两个组合不能相同。

      **所以我们要去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重**。

  - 正确解法

    - 为了在横向遍历中快速找出重复元素，也为了剪枝，我们先排序

    - 因为排序了，所以横向遍历中，如果有重复元素，那他们必然相邻，此时不进行递归

    - ```cpp
      class Solution
      {
      public:
          vector<vector<int>> res;
          vector<int> path;
          vector<vector<int>> combinationSum2(vector<int> &candidates, int target)
          {
              res.clear(), path.clear();
              sort(candidates.begin(), candidates.end());
              func(candidates, 0, candidates.size(), target, 0);
              return res;
          }
          void func(vector<int> &candidates, int left, int right, int target, int sum)
          {
              if (target == sum)
              {
                  res.push_back(path);
                  return;
              }
              // 顺便剪枝
              for (int i = left; i < right && sum + candidates[i] <= target; i++)
              {
                  // 在横向遍历中，不能出现重复元素
                  // 检查i!=left，因此该元素没有前值
                  if (i != left && candidates[i] == candidates[i - 1])
                  {
                      // 该元素出现过
                      continue;
                  }
                  // 处理当前结点
                  path.push_back(candidates[i]);
                  sum += candidates[i];
                  // 递归
                  // 在递归里面可以出现重复元素，只要不是自己、不回头即可
                  func(candidates, i + 1, right, target, sum);
                  // 回溯
                  sum -= candidates[i];
                  path.pop_back();
              }
          }
      };
      ```

- 2022年3月8日上午，回溯

  - 131，分割回文串

    - 这个题目不是穷举所有可能的子串，然后判断是不是回文串

      - 这样的话，遍历空间是整棵树，且二重循环可以解决这个问题

    - 题目的意思是

      - 要求对这个字符串进行连续的分割

        使分割出来的字符串均为回文串

        而不是简单的找子串并判断

    - 也比较简单

      - 设置一个左边界（初始为0），然后从左边界开始划分出一个子串
      - 如果是回文串，处理之，并递归，此时左边界+1
      - 否则，继续找子串
      - 最后，当左边界越界时，停止，因为左边界能越界，所以已经将所有字符都处理了，应该将path（所有连续的子串）放入结果集

    - **本题我相信很多同学主要卡在了第一个难点上：就是不知道如何切割，甚至知道要用回溯法，也不知道如何用。也就是没有体会到按照求组合问题的套路就可以解决切割**。

      - 切割就是划分子串，因为是连续划分，所以左边界根据参数获得，右边界就是遍历

    - ![Screenshot_20220308_093339_com.newskyer.draw](https://gitee.com/hit_whr/pic_2.0/raw/main/Screenshot_20220308_093339_com.newskyer.draw.jpg)

  - 93，复原ip地址

    - 老套路

      - 设置左边界，然后横向遍历找右边界
        - 如果确定的字符串超过了255，没必要再往右找了（剪枝）
        - 如果左边界为0，则右边界必须和左边界相等，确保不出现前导0（以免再讨论）
      - 结束条件
        - 当path中放了四个值时
          - 如果搜索完s（left越界），则放入结果
          - 如果没搜索完，则退出

    - ![image-20220308154835304](https://gitee.com/hit_whr/pic_2.0/raw/main/image-20220308154835304.png)

      

    - ![image-20220308103949616](https://gitee.com/hit_whr/pic_2.0/raw/main/image-20220308103949616.png)

    - string转int

      - sstream

        - ```cpp
          strstream s;
          string a = "33";
          int a_int;
          s << a;
          s >> a_int;
          cout << a_int << endl; // 33
          ```

          

      - atoi

        - 这里首先要将string转成c类型的字符串（字符数组）

        - ```cpp
          string a = "22";
          int a_int = atoi(a.c_str());
          cout << a_int << endl; // 22
          ```

          

      - stoi

        - ```cpp
          string a = "11";
          int a_int = stoi(a);
          cout << a_int << endl; // 11
          ```

          

  - 对比

    - 组合问题，最终是收集叶子结点的结果（path）
    - 分割问题，最终是收集叶子结点的结果（path）
    - 子集问题，因为要找所有可能的结果，所以是收集所有结点的结果（path）

  - 题目

  - 78，求子集

  - 90，有重复元素求子集

    - <img src="https://gitee.com/hit_whr/pic_2.0/raw/main/Screenshot_20220308_155657_com.newskyer.draw.jpg" alt="Screenshot_20220308_155657_com.newskyer.draw" style="zoom: 33%;" />

  - 491，递增子序列

    - 给定一个序列，可能有重复元素

      要得到该序列的子序列，且该子序列为非递减序列（当出现重复元素时）

      非递减序列至少有两个元素

      [4,4,3,2,1]

      [[4,4]]

      [4,6,7,7]

      [[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]

    - 几个关键点

      - 序列中至少有两个元素
        - 所以在用null时，应该检查path中的元素个数
      - 非递减
        - 如果path中有元素，要放入的元素>=path尾部元素
          - **此处别忘了检查path.size()**
      - 纵向遍历可以用重复元素
        - 不能回头，不能再用自己
      - 横向遍历不能用重复元素
        - [4,6,4,5]
          - [4,5]和[4,5]重复
        - 因为这是序列，显然不能排序，如何保证不重复？
          - 每层都用一个map
          - 当试图访问一个不存在的key时，默认返回零值，也就是未访问过
          - 访问之后，将value修改为true

    - ![Screenshot_20220308_164227_com.newskyer.draw](https://gitee.com/hit_whr/pic_2.0/raw/main/Screenshot_20220308_164227_com.newskyer.draw.jpg)

  - 46，全排列

    - 全排列

      给一个数组，没有重复元素

      返回所有排列情况

      nums = [1,2,3]

      输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

    - 排列是将顺序的，1,2,3和3,2,1是不同的结果，所以搜索到3时

      - 需要往回看，也就是说不需要一个参数来记录左边界
      - 不能重复选，所以需要一个数组来记录在树的一条路径中，该值是否被用过
        - 可以用map建立值到bool的映射
        - 也可以直接用bool数组，建立nums的下标到bool数组下标到bool值的映射

    - 排列中，横向遍历可以是所有值

      纵向遍历，只要这个值在这个路径上没访问过，都可以访问

      因为是路径访问记录，所以参数应该放到回溯函数中或者设置为全局变量

    - 参数：

      - 数组，访问记录

    - 终止条件

      - 如果path的元素个数和数组的元素个数相同，也就是说到了叶子结点，应该记录该路径

    - ![image-20220308190432218](https://gitee.com/hit_whr/pic_2.0/raw/main/image-20220308190432218.png)

    - ![7](https://gitee.com/hit_whr/pic_2.0/raw/main/image-20220308190639564.png)

  - **47，有重复元素的全排列**

    - 给定一个数组，可能有重复元素

      输出其全排列

      因为有重复元素，所以可以对数组排序

      [1,1,2,3]

      [1,1,2,3],[1,2,1,3],[1,2,3,1],

      [1,1,3,2],[1,3,1,2],[1,3,2,1],

      [1,2,1,3],[2,1,1,3],[2,1,3,1],

      [1,2,3,1],[2,1,3,1],[2,3,1,1],

      [1,3,1,2],[3,1,1,2],[3,1,2,1],

      [1,3,2,1],[3,1,2,1],[3,2,1,1]

      

    - 横向遍历不重复，纵向遍历不重复使用一个元素

    - 前面采用map来记录，这里换一下，使用bool数组

      - 两种方法是等价的

    - 这个题目有意思

      - 组合，无重复元素

        - 横向，不需要考虑重复
        - 纵向，引入左边界作为参数，不回头，不用自己

      - 组合，有重复元素

        - 横向，排序，跳过和左侧元素重复的元素
        - 纵向，引入左边界作为参数，不回头，不用自己

      - 排列，无重复元素

        - 横向，不需要考虑重复
        - 纵向，可以回头，但是不能用自己，引入访问记录

      - 排列，有重复元素

        - 横向，排序，考虑重复

        - 纵向，可以回头，不能用自己

        - 也就是说有重复元素的排列需要同时检查横向和纵向

        - 但是这里有个**逻辑bug**

          ```cpp
          // 如果访问过（纵向）或者和左侧相同（横向），跳过
          if (record[i] || i != 0 && nums[i] == nums[i - 1]){
          	continue;
          }
          ```

          1,1,2先选1.

          第一个1由于用过，不能选，第二个1由于重复不能选.

          ***也就是说在纵向遍历时，额外加上了横向遍历的条件***

          **所以要区分什么时候在纵向遍历，什么时候在横向遍历：**

          - ![Screenshot_20220308_202244_com.newskyer.draw](https://gitee.com/hit_whr/pic_2.0/raw/main/Screenshot_20220308_202244_com.newskyer.draw.jpg)
          - 如果左值没访问过，表示在横向遍历，此时如果和左值相同，则跳过

        - 怎么解决这个逻辑bug呢？
        
          - 区分同一树层和同一树枝。
            - 同一树层就是指横向遍历
              - 横向遍历/同一树层不可重复的条件为`if (i != 0 && nums[i] == nums[i - 1] && record[i - 1] == false) continue;`
            - 同一树枝就是指纵向遍历
              - 纵向遍历/同一树枝不可重复的条件为`if (i != 0 && nums[i] == nums[i - 1] && record[i - 1] == true) continue;`
        
          - ![image-20220308204422332](https://gitee.com/hit_whr/pic_2.0/raw/main/image-20220308204422332.png)

    - ![Screenshot_20220308_202453_com.newskyer.draw](https://gitee.com/hit_whr/pic_2.0/raw/main/Screenshot_20220308_202453_com.newskyer.draw.jpg)

    - 动态数组申请及初始化

      - ```cpp
        // 动态数组申请
        bool *record;
        // 用()时，会对数组元素用简单类型的默认值进行初始化
        record = new bool[5]();
        for (int i = 0; i < 5; i++)
        {
            cout << record[i] << " ";
        }
        cout << endl; // 0 0 0 0 0
        
        // 不用()，不会初始化
        record = new bool[5];
        for (int i = 0; i < 5; i++)
        {
            cout << record[i] << " ";
        }
        cout << endl; // 0 40 95 2 0
        ```

- 2022年3月9日上午


  - 319，重新安排行程

    - 第一版

      - path应该首先将出发地放进去，否则将所有票都使用后，也无法满足`path.size() == tickets.size() + 1`

    - 第二版

      - 在建立票（from_city, to_city）的映射时，应该映射为int，而不是bool。因为票可能重复。		

    - 第三版

      - 思路是搜索整棵树，将所有可能的路径都放入热死，然后取第一个值。

        因为city在set<string>中是有序（字典序）的，所以可以保证第一条搜索到的路径的字典序最小

        但是这样会超时，因为题目只需要一条最短的路即可

    - 第四版
      - 设置一个标记，当搜索到一条path时，停止遍历
        - 不遍历整棵树

  - 总结一下

    - 组合
    - 分割
    - 子集
    - 排列

  

  

- 20223月9日晚上，贪心法


  - 贪心算法

      - **贪心的本质是选择每一阶段的局部最优，从而达到全局最优**。
      - 如果出现最大最小值的问题，一般采用贪心算法，因为贪心算法解决最优性问题
      - 如果贪心不能解决，可以换动态规划

  - 455，分饼干

      - 数组g为每个孩子的最小胃口，s为饼干的尺寸

        目标是分配饼干，满足尽可能多的孩子

    - 一个大饼干，如果不去满足胃口大的，而是去满足胃口小的，那么小饼干其实是被浪费了，因为小饼干满足不了胃口大的

    - 解法

    - 首先对g和s降序排序

      - 对于最大的饼干，应该分配给能满足条件且胃口最大的孩子

    - 实现

      - 在实现时，不需要两重for循环，因为两重循环的本质是穷举，而这里实际上只遍历了胃口数组

      - ```cpp
        int cnt = 0;              // 计数值
        int index = s.size() - 1; // 待分配饼干的下标
        // 反向遍历胃口数组
        for (int i = g.size() - 1; i >= 0 && index >= 0; i--)
        {
            if (s[index] >= g[i])
            {
                cnt++;
                index--; // 分配饼干
            }
        }
        ```

  - 376，最长摆动子序列

      - 子序列是原序列删除一些元素或不删除元素的结果

        摆动序列是每个后值减去前值的差是正负交替的，差值不能为0

        摆动序列可以只有一个元素，或者两个不等的元素

        也就是说，摆动序列在折线图上，升降交替，不出现平台

      - 思路就是找单调序列

          - 解法1

              - 从前往后开始遍历

              - 如果前值=后值，计数值不变，i++

              - 如果前值<后值，则while这个条件或前值=后值成立，i++

                  - 这里特别注意一下，如果出现前值<后值，除非出现前值>后值，否则都应该继续查找
                  - 当出现前值=后值时，单调性仍然没有改变
                  - 最后计数值+1

              - 如果前值>后值，则while这个条件或前值=后值成立，i++

                  - 最后计数值+1

            - ```cpp
              int wiggleMaxLength(vector<int> &nums)
                  {
                      if (nums.empty())
                      {
                          return 0;
                      }
                      // 就是找单调区间的个数
                      int cnt = 1;
                      int i = 0;
                      while (i < nums.size() - 1)
                      {
                          if (nums[i] == nums[i + 1])
                          {
                              i++;
                              continue;
                          }
                          else if (nums[i + 1] > nums[i])
                          {
                              // 这里要加上等号，否则如果先递增，平台，再递增，会增加两个计数值
                              while (i < nums.size() - 1 && nums[i + 1] >= nums[i])
                              {
                                  // cout << nums[i + 1] << " > " << nums[i] << endl;
                                  i++;
                              }
                              cnt++;
                          }
                          else
                          {
                              // 同样要加等号
                              while (i < nums.size() - 1 && nums[i + 1] <= nums[i])
                              {
                                  // cout << nums[i + 1] << " < " << nums[i] << endl;
                                  i++;
                              }
                              cnt++;
                          }
                      }
                      return cnt;
              }
              ```

            - 

        - 解法2

          - 引入一个变量来记录之前的差值符号

          - ```cpp
            int wiggleMaxLength3(vector<int> &nums)
            {
                if (nums.empty())
                {
                    return 0;
                }
                int preDiff = 0; // 之前的差值
                int curDiff = 0; // 当前的差值
                int cnt = 1;     // 计数值
                for (int i = 0; i < nums.size() - 1; i++)
                {
                    curDiff = nums[i + 1] - nums[i];
                    if (curDiff == 0)
                    {
                        continue;
                    }
                    // =0，是考虑到初始值
                    // 之后，不会出现preDiff=0
                    else if (curDiff > 0 && preDiff <= 0)
                    {
                        preDiff = curDiff;
                        cnt++;
                    }
                    else if (curDiff < 0 && preDiff >= 0)
                    {
                        preDiff = curDiff;
                        cnt++;
                    }
                }
                return cnt;
            }
            ```

          - 

    - 引申

      - 找到该子序列
      - 经过上面的分析，最长摆动子序列不唯一，但是长度是唯一的
      - 如果左值=右值，不放入
      - 如果左值<右值，当左值不大于右值时，继续遍历
        - 退出时，将当前结点（局部最大值）放入
      - 如果左值>右值，当左值不小于右值时，继续遍历
        - 退出时，将当前结点（局部最小值）放入

    - 53，最大子数组和

      - 要求是连续的数组

        使之和最大

        从头开始遍历，记录和，如果大于max，更新max

        如果和变为负，表明现在引入的值抵消了之前的所有成果

        所以不能引入这个值

        反向来看，对于当前值，前面的和如果大于max，则该值已经被记录

        如果前面的和为正，则会增加当前值，应该放入

        但是为负值，就不要放入了，因为从当前值开始，和会更大

      - 细节

        - 将max初始化INT_MIN后，更新sum，只要max没sum大，就应该更新max。如果sum为负，不可能对后面有帮助，将sum置为0

        - ```cpp
          int max = INT_MIN;
          int sum = 0;
          for (auto num : nums)
          {
              sum += num;
              max = sum > max ? sum : max;
              if (sum < 0)
              {
                  sum = 0;
              }
          }
          ```

    - **55，跳跃游戏**

      - 一开始的想法

        - 搜索可达范围index+1到index+nums[index]这个范围内的最大值，也就是下次可以移动的最大值，但是下次可以一定的最大值，不一定代表下下次可以移动到最大位置，这还受该位置的影响

        - 可以修改为找i+nums[i]的最大值

          - 可行

          - ```cpp
            // [2,3,1,1,4]
            bool canJump(vector<int> &nums)
            {
                int index = 0;
                while (index < nums.size())
                {
                    // 刚好到达
                    if (index == nums.size() - 1)
                    {
                        return true;
                    }
                    // 走不动了且没有到达终点
                    if (nums[index] == 0)
                    {
                        return false;
                    }
                    // 不需要经过中间结点就能到达
                    // 同时防止index+nums[index]越界
                    if (index + nums[index] >= nums.size() - 1)
                    {
                        return true;
                    }
                    // 借助中间结点
                    // 搜索可达范围内(index+1到index+nums[index])范围内的最大值+索引值对应索引
                    // 这才是下次可以到达的最远地方
                    // 4,2,0,0,1,2
                    index = get_max_index(nums, index);
                }
            }
            int get_max_index(vector<int> &nums, int index)
            {
                int max_index = index + 1;
                int max = nums[max_index];
                for (int i = index + 1; i <= index + nums[index]; i++)
                {
                    if (nums[i] + i >= max + max_index)
                    {
                        max_index = i;
                        max = nums[i];
                    }
                }
                return max_index;
            }
            ```

        - bug记录：

          - 增加是否需要通过中间结点的判断
            - 2,0,0
          - 如果在可达范围内，有多个最大值，应该选最远的
            - [5,9,3,2,1,0,2,3,3,1,0,0]
          - 修改最大的含义：index+nums[index]在可达范围内最大
            - [4,2,0,0,1,1,4,4,4,0,4,0]，可达范围内的最远不一定是最优的，这太短视了

      - 正确想法

        - 和上面的想法差不多

        - 定义一个变量furthest

          - 这个变量=下标+对应的数组值
          - 每次遍历取最大值，如果更新后，>=size-1，true
          - 遍历结束时，都没有满足上述条件，false

        - 比较巧妙的是，遍历的范围为furthest，也就是说遍历的范围是动态更新的

          - ```cpp
            // 进一步精简代码，用furthest来代替i+nums[i]
            // 比较巧妙的是循环条件中有furthest，且在循环汇总更新该变量
            // [2,3,1,1,4]
            bool canJump(vector<int> &nums)
            {
                // 遍历中发现能到达的最远位置
                int furthest = 0 + nums[0];
                // index<=furthest
                for (int index = 0; index <= furthest; index++)
                {
                    furthest = (index + nums[index]) > furthest ? (index + nums[index]) : furthest;
                    if (furthest >= nums.size() - 1)
                    {
                        return true;
                    }
                }
                // 搜索到的furthest没到最后一个元素
                return false;
            }
            ```

  - 2022年3月10日上午，贪心

      - **45，跳跃游戏**

          - 55是输出能否跳过去

            45是输出跳过去的最小步数

        - 这里的写法和55的第一种解法很像了

          - 每一次的跳跃，都需要保证跳跃位置的i+nums[i]达到最大值

          - 注意点

            - 如果没有到达最后位置
              - 如果跳跃步数为0，则不能到达
              - 必须看是否需要中间结点
                - 如果当前的furthest就能到达，cnt++后直接返回
                - 如果不能到达，必须借助中间结点
                  - 在pwd_loc+1和furthest之间找到i+nums[i]最大的结点

          - ```cpp
            int jump(vector<int> &nums)
            {
                // 每次选择i+nums[i]最大的进行跳跃
                int pwd_loc = 0;
                int furthest = pwd_loc + nums[pwd_loc];
                int cnt = 0;
                while (pwd_loc < nums.size() - 1)
                {
                    // 没到最后位置，且不能前进
                    if (nums[pwd_loc] == 0)
                    {
                        return -1;
                    }
                    // 不需要中间结点即可到达
                    if (furthest >= nums.size() - 1)
                    {
                        cnt++;
                        break;
                    }
                    // 还需要中间结点
                    // 在pwd_loc+1到furthest间找i+nums[i]的最大值
                    int i = pwd_loc + 1;
                    int max_index = i;
                    int max = i + nums[i];
                    for (; i <= furthest; i++)
                    {
                        if (i + nums[i] > max)
                        {
                            max = i + nums[i];
                            max_index = i;
                        }
                    }
                    // 修改pwd_loc
                    pwd_loc = max_index;
                    // 同时修改furthest
                    furthest = max;
                    cnt++;
                }
                return cnt;
            }
            ```

            

- 2022年3月10日下午，贪心法

  - 1005

    - 对nums中的元素进行k次取反，使得最后的数组和最大

    - 贪心

      - 首先将负值较大的负数取反。
      - 如果次数还有剩余，且次数为奇数，将正值较小的整数取反；如果次数为偶数，显然连续取反偶数次，不影响最终结果。

    - 实施

      - 可以按照升序排序

        - ```cpp
          int largestSumAfterKNegations(vector<int> &nums, int k)
          {
              int i = 0;
              // 升序排序
              sort(nums.begin(), nums.end());
              while (i < nums.size() && k != 0)
              {
                  // 对负数取反
                  if (nums[i] < 0)
                  {
                      nums[i] = -nums[i];
                      k--;
                      i++;
                  }
                  // 遇到正数或0
                  else
                  {
                      // 对最小非负数取反
                      if (k % 2 != 0)
                      {
                          // 最小非负数出现在i或者i-1处
                          int index = i;
                          if (i - 1 >= 0 && nums[i - 1] < nums[i])
                          {
                              index = i - 1;
                          }
                          nums[index] = -nums[index];
                          k = 0;
                      }
                      break;
                  }
              }
              // 查看退出循环的原因
              // if (k == 0)
              // {
              //     // 不需要继续处理
              //     // 直接求和
              // }
              // i越界
              // else
              if (k != 0)
              {
                  // 对最小的非负数取反
                  if (k % 2 != 0)
                  {
                      nums[nums.size() - 1] = -nums[nums.size() - 1];
                  }
              }
              // 对序列求和
              int sum = 0;
              for (auto i : nums)
              {
                  sum += i;
              }
              return sum;
          }
          ```

        - 

      - 可以按照绝对值将序排序

        - 

  - 134，加油站

    - gas，cost，res

    - 贪心

      - 类似于最大子数组和（要求连续）

      - 如果[i,j]的res之和为正，根据计算过程，[i,k]\(i<=k<=j\)的res和都为正

      - 如果[i,j]的res之和为负，显然该负数的绝对值大于[i,j-1]的res之和

        - 如果从[i.j]之间的某个点k出发，[i,k-1]为正，[k,j-1]<[i,j-1]，则[k,j]还是为负
        - 所以[i,j]之间的点都不能作为新的出发点
        - 应该选择j+1作为出发点
        - <img src="https://gitee.com/hit_whr/pic_2.0/raw/main/Screenshot_20220310_162524_com.newskyer.draw.jpg" alt="Screenshot_20220310_162524_com.newskyer.draw" style="zoom: 33%;" />

      - 这里的局部最优是指保证start（更新中）到end是可行的（和一直为正）

      - 潜在条件是，如果总油量>总耗油量，则一定存在解

      - 代码

        - 别忘记将局部变量初始化

        - start也不会越界，因为对total进行了检查

        - 

          ```cpp
          int canCompleteCircuit3(vector<int> &gas, vector<int> &cost)
          {
              int total = 0, res = 0;
              int start = 0;
              for (int i = 0; i < gas.size(); i++)
              {
                  cout << res << endl;
                  total += (gas[i] - cost[i]);
                  res += (gas[i] - cost[i]);
                  // 累加和出现复制，应该更新起点
                  // start会不会越界
                  // 当i已经到gas.size()-1时，如果res还是负，则start=gas.size()
                  // 显然此时start越界了
                  // 但是由于到最后，res还是负值，前面若干个子区间的和也为负值（只有出现负值才会更新res）
                  // 那么total必然也为负，返回-1，所以start不会越界
                  if (res < 0)
                  {
                      res = 0;
                      start = i + 1;
                  }
              }
              // 检查有没有解
              if (total >= 0)
              {
                  return start;
              }
              else
              {
                  return -1;
              }
          }
          ```

        - 

    - 二重循环

      - 超时
      - 如何实现二重循环
        - 外层是起点，从头到尾的遍历，for
        - 内层是起点++然后取余，知道加回到起点的环形遍历
          - 适合用while实现
          - 

- 2022年3月11日上午，贪心法

  - 135，分发糖果
    - 两次贪心
      - 从左往右遍历，如果右侧比左侧评分高，右侧=左侧+1
      - 前面处理了右侧>左侧的情况，还可能出现1,4,3这种4比左侧和右侧都大的情况
      - 从右往左遍历，如果左侧比右侧评分高，左侧=max（左侧，右侧+1）
    - 数组初始化为1
    - 贪心算法的过程比较简单，**如果出现很多条件判断**，要注意此时是不是贪心了
    - ![image-20220311094753181](https://gitee.com/hit_whr/pic_2.0/raw/main/image-20220311094753181.png)
  - 860，柠檬水找零
    - 柠檬水5元，可能收到5/10/20的，要求找零，如果都能找零，返回true；否则，返回false。
    - 收到5元，不需要找零
    - 收到10元，只能用5元找零
    - 收到20元，优先用10+5找零，其次用5+5+5找零，因为5可以给10/20找零

- 2022年3月11日下午，贪心法

  - 406，根据身高重建队列

    - 输入为打乱顺序后的数组

      每一项的第一个值表示身高，第二个值表示前面>=该身高的人数

      要求输出数组原来的顺序，使得每一项的第二个值满足身高约束

      [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]

      [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]

    - 贪心法

      - 应该首先根据身高较高的第二项安排位置（其实是优先级较低）

        但是身高较低的优先级较高，因为将身高较低的放在左侧，不会影响第二项的正确性

        所以发生重复，也就是某两项的第二项相同时，应该优先放身高较低的

        也就是说，如果被占据，应该将右侧序列集体右移

        ![Screenshot_20220311_162314_com.newskyer.draw](https://gitee.com/hit_whr/pic_2.0/raw/main/Screenshot_20220311_162314_com.newskyer.draw.jpg)
      
    - 改进点

      - 插入操作

        - 手写

          - 因为是对数组的插入操作，所以需要判断某个地方是否已经有了元素
            - 如果没有元素，直接赋值
            - 如果有元素，要将后面的元素移动

        - stl

          - vector提供了insert方法，将某个值插入到某个位置

            - 工作过程

              - 首先检查vector的size是否等于capacity

                - 是，capacity*2，拷贝原数组

              - 然后移动insert位置后的元素，并将待插入元素放到指定位置

              - ```cpp
                vector<int> res(4, 0);
                cout << "capacity:" << res.capacity() << endl;
                res.insert(res.begin() + 1, 1);
                cout << "capacity:" << res.capacity() << endl;
                for (auto i : res)
                {
                    cout << i << endl;
                }
                
                capacity:4
                capacity:8
                0
                1
                0
                0
                0
                ```

              - 如果insert的位置不在数组范围内（size）会出错

                - 0，占用起始位置

                - size-1，占用最后一个位置

                - size，放到最后一个元素后面

                - \>size，出错

                  - ```cpp
                    vector<int> res(4, 0);
                    cout << "capacity:" << res.capacity() << endl; // 只执行到这里
                    res.insert(res.begin() + 5, 1);
                    cout << "capacity:" << res.capacity() << endl;
                    for (auto i : res)
                    {
                        cout << i << endl;
                    }
                    cout << "end\n";
                    ```

                    

            - 缺点是，如果vector（底层是动态数组）的大小（capacity，容量）频繁变化

              - 一是如果容量不够，需要拷贝数组进行扩容（capacity，容量）
              - 二是，需要移动元素，此时vector的大小也会变化，所以无法预设vector的大小

          - 如果用list（链表），插入的效率会

  - 452，用最少的箭射气球

    - 给出气球的直径区间，返回最少箭的数量，使得所有气球都被射爆

    - 首先对气球按照左边界升序排序，右边界升序排序

      检查第i+1个气球的左边界

      如果在第i个左右边界之间，表明有重叠

      因为第i个气球肯定是要被射爆的，所以需要将他们一起射爆

      位置为这两个气球右边界的最小值

      然后检查后面气球是否包括这个位置，如果在，同时被射爆

      - 这个思路前面都对，但是有一点不对，在检查i+2时，如果i+2的右边界比射击位置小，应该继续更新射击位置
        - 为什么呢？
        - 因为随着i递增，左边界递增，只要左边界在射击范围内，一定能射中
        - 这时为了能射中更多的气球（第一个气球肯定要消耗箭，现在就看能不能额外多射中），应该让射击位置<=所以气球的右边界，这样射击位置<=最小右边界，必然>=最大左边界
        - <img src="https://gitee.com/hit_whr/pic_2.0/raw/main/image-20220312094843934.png" alt="image-20220312094843934" style="zoom: 50%;" />
        - <img src="https://gitee.com/hit_whr/pic_2.0/raw/main/Screenshot_20220312_095001_com.newskyer.draw.jpg" alt="Screenshot_20220312_095001_com.newskyer.draw" style="zoom: 33%;" />

- 2022年3月12日上午，贪心法


     - **435，无重叠区间**


          - 给若干个区间，要求删除一些区间，使得剩下的区间没有重叠

               且要求删除的个数最少

               返回删除区间的个数

          - 首先对区间按照左边界递增、右边界递增的顺序排序

          - 显然不能从左遍历，因为是按照左边界递增的顺序排序

               从左遍历，右边界可能非常大，占用很大的位置

               比如[[1,10],[1,2],[2,3],[3,4]]

               所以应该从右往左遍历

     - 763，划分字母区间


          - 对s进行连续划分

               要求：子区间的字母组成不能有交集

               子区间的数目最多

               返回子区间的长度

          - 从start开始，反向搜索，找到s[start]最后出现的位置pos，记录在map中

               并与end比较，如果pos大，更新end（遍历范围）

               继续正向遍历，当遍历到最终位置时，将end-start+1放入结果，作为子区间的长度


               - **这个思路和55差不多，都对遍历的区间进行了动态更新**

          - ![Screenshot_20220312_163634_com.newskyer.draw](https://gitee.com/hit_whr/pic_2.0/raw/main/Screenshot_20220312_163634_com.newskyer.draw.jpg)

          - 解法1


               - ```cpp
                    class Solution
                    {
                    private:
                        map<char, int> my_map;
                        // 在s中找到c的最后出现位置
                        int lastPosition(const string &s, char c)
                        {
                            // map中有对应记录
                            auto pos_it = my_map.find(c);
                            if (pos_it != my_map.end())
                            {
                                return pos_it->second;
                            }
                            // 从右往左查找
                            for (int i = s.size() - 1; i >= 0; i--)
                            {
                                if (s[i] == c)
                                {
                                    my_map[s[i]] = i;
                                    return i;
                                }
                            }
                        }
                    
                    public:
                        vector<int> partitionLabels(string s)
                        {
                            vector<int> res;
                            int start = 0;   // 开始遍历位置
                            int end = start; //最终遍历位置
                            // 这里取等于，是要考虑最后一个元素
                            while (end <= s.size() - 1)
                            {
                                // 这里不取等于，是因为当end到达最后面时，没必要再检查了
                                for (int i = start; i <= end && end < s.size() - 1; i++)
                                {
                                    // 找到最后出现位置
                                    int last_pos = lastPosition(s, s[i]);
                                    // 动态更新最终遍历位置
                                    end = last_pos > end ? last_pos : end;
                                    // cout << "char:" << s[i] << " last_pos:" << end << endl;
                                }
                                res.push_back(end - start + 1);
                                // 更新start和end
                                start = end + 1;
                                end = start;
                            }
                            return res;
                        }
                    };
                    ```

          - 解法2


               - ```cpp
                    class Solution {
                    public:
                        vector<int> partitionLabels(string S) {
                            int hash[27] = {0}; // i为字符，hash[i]为字符出现的最后位置
                            for (int i = 0; i < S.size(); i++) { // 统计每一个字符最后出现的位置
                                hash[S[i] - 'a'] = i;
                            }
                            vector<int> result;
                            int left = 0;
                            int right = 0;
                            for (int i = 0; i < S.size(); i++) {
                                right = max(right, hash[S[i] - 'a']); // 找到字符出现的最远边界
                                if (i == right) {
                                    result.push_back(right - left + 1);
                                    left = i + 1;
                                }
                            }
                            return result;
                        }
                    };
                    ```

                    

          - 区别


               - 最后一次出现位置

                    - 解法1遇到一个元素就找一次最后出现位置

                         - 优点是从后往前开始查找（因为此时目的明确）
                         - 虽然用了map来避免重复操作记录之前操作的结果，但是仍然可能找很多次
                    - 解法2一次遍历，即可获得所有元素的最后出现位置

                         - 空间复杂度为O(1)
                         - 又是一次动态更新过程
               - 正向遍历过程

                    - 解法1比较符合思维过程
                    - 解法2更加简洁

                         - 当遍历点==end时，表明应该生成子字符串了

     - 56，合并区间


          - 对二维数组按照左边界升序、右边界升序排序
          - 如果intervals[i]\[0\]<=intervals[i-1]\[1\]，由于intervals\[i\][0]>=intervals[i\][0]是排序结果
          - 所以i的左边界在i-1的左、右边界之间，是一定有重叠的，此时需要更新重叠区间的右边界值
          - 注意

               - 对于最后一个区间

                    - 如果它和之前的区间有重叠，不会放入结果
                    - 如果没有重叠，更新重叠区间的左右边界之后，也不会放入结果
                    - 所以for结束之后，还应该放一次

     - 738，单调递增的数字


          - 如果一个数字从左到右的所有相邻位都满足左侧<=右侧，则称这个数是单调递增的

               给定一个n，找到一个i，使得i为不超过n的最大单调递增整数

          - 从左往右遍历


               - if bits[i-1]<=bits[i],continue

                    **else: 向左找到和bits[i-1]相等的，令其值为bits[i-1] - 1，后面的位都补9**

                    这里必须要往左找相等的，否则修改i-1，i-1会和它左侧的冲突


                    - **如332**

          - 从右往左遍历


               - if bits[i-1]<=bits[i],continue

                    else:bits[i]=9（以及i右侧的值）,bits[i-1]--

               - 这样遍历不需要像从左往右遍历一样往回看，为什么？


                    - 因为不满足条件时，肯定要将bits[i]置为9，将bits[i-1]--，但是从左往右遍历，bits[i-1]--，修改了右侧的值，可能会使bits[i]<=bits[i-1]这个条件不再满足
                    - 而从右往左遍历，bits[i]修改成了最大的数，bits[i-1]虽然自减，但是后续还会处理到bits[i-1]，如果比bits[i-2]小，无非再处理一次

          - 进一步优化


               - 不需要进行整数分拆

                    - 直接转string，然后对char运算
                    - 最后将string转int
               - 不需要遇上一次不符合条件的就将右侧所有元素置9，只需要记录位置，因为在遍历中用不到这些被置9的元素了

                    - 最后一次性置9

          - ![image-20220312211334721](https://gitee.com/hit_whr/pic_2.0/raw/main/image-20220312211334721.png)

     - 


     - 
     - 
     - 题目		

- 2022年3月13日上午，动态规划


     - 动态规划解题步骤

          1、确定dp数组（dp table）以及下标的含义

          - 动态规划引入辅助数组，所以肯定是有空间复杂度的

          2、确定递推公式

          3、dp数组如何初始化

          4、确定遍历顺序

          5、举例推导dp数组

     - 509，斐波拉契数列


          - 1、数组含义：dp[i]表示第i个斐波拉契数

               2、递推公式：dp[i]=dp[i-1]+dp[i-2]

               3、初始化：dp[0]=0,dp[1]=1

               4、遍历顺序：从左往右

     - 70，爬楼梯


          - 从平地开始，爬到第n层，每次最多可以上两层，问有多少种方法可以上到第n层

          - 1、数组含义：dp[i]表示爬到第i层的方法数

               2、递推公式：dp[i]=dp[i-1]+dp[i-2]

               爬到i之前，如果最后走一层，那么之前在i-1；如果走两层，那么之前在i-2

               3、初始化：dp[1]=1,dp[2]=2

               4、遍历顺序：从前往后

     - 70，爬楼梯引申


          - 从平地开始，爬到第n层，每次最多可以上m层，问有多少种方法可以上到第n层

          - 这题加了一个参数m，实际上只是影响了递推公式和初始化

          - 1、数组含义：dp[i]表示爬到第i层的方法数

               2、递推公式：dp[i]=dp[i-1]+dp[i-2]+dp[i-n]+...+dp[i-m]，1=<n<=m，i-m>=0

               3、初始化：**dp[0]=1，主要是考虑到从0直接上到i的情况**

               4、遍历顺序：从前往后

          - ```cpp
               int climbStairs(int n, int m)
               {
                   vector<int> dp(n + 1, 0);
                   dp[0] = 1;
                   for (int i = 1; i <= n; i++)
                   {
                       for (int n = 1; n <= m && i - n >= 0; n++)
                       {
                           dp[i] += dp[i - n];
                       }
                       cout << "i=" << i << " dp[i]=" << dp[i] << endl;
                   }
                   return dp[n];
               }
               ```

          - 这个引申版本更具有一般性，因为它只对一个值进行了初始化，后续值的求解都可以通过递推公式+范围限制（不越界）得到

     - 746，最小花费爬楼梯

       - 1、数组含义：dp[i]表示到第i层的最小花费且已支付该层费用

         2、递推公式：dp[i]=min(dp[i-1],dp[i-2])+cost[i]

         3、初始化：dp[0]=cost[0],dp[1]=cost[1]，因为可以从0或1出发

         4、遍历顺序：从左往右

         最后取dp[dp.size()-1]（最后走一步）和dp[dp.size()-2]（最后走两步）的最小值

       - ![Screenshot_20220313_093748_com.newskyer.draw](https://gitee.com/hit_whr/pic_2.0/raw/main/Screenshot_20220313_093748_com.newskyer.draw.jpg)

     - 62，不同路径

       - 1、数组含义：dp[i]\[j\]表示从[0]\[0\]到[i]\[j\]的方法数

         2、递推公式：dp[i]\[j\]=dp[i-1]\[j\]（向右移动）+dp[i]\[j-1\]（向上移动）(i-1>=0,j-1>=0)

         3、初始化：dp[0]\[i\]=1，dp[j]\[0\]=1

         4、遍历顺序：横、纵

         - ```cpp
           for (int i = 1; i < m; i++)
           {
               for (int j = 1; j < n; j++)
               {
                   // 遍历顺序保证，在此之前dp[i-1][j]（上一行）被求出
                   // dp[i][j-1]（上一个值）被求出
                   dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
               }
           }
           ```

           

       - 相较于前面的题，这题的dp是二维数组，递推公式、初始化和遍历顺序也都是二维的

       - vector初始化

         - 一维vector

           - ```cpp
             // 一维数组初始化，指定个数和初始值
             vector<int> data(3, 2);
             for(auto i:data){
                 cout << i << " ";
             }
             cout << endl;
             gap();
             2 2 2
             -------------
                 
             // 一维数组初始化，指定序列值
             vector<int> data{1, 2, 3};
             for (auto i : data)
             {
                 cout << i << " ";
             }
             cout << endl;
             gap();
             1 2 3
             -------------
             ```

             

         - 二维vector

           - ```cpp
             // 初始化为row*column的矩阵，不指定初始值
             int row = 3, column = 4;
             vector<vector<int>> matrix(row, vector<int>(column));
             for (auto outer : matrix)
             {
                 for (auto inner : outer)
                 {
                     cout << inner << " ";
                 }
                 cout << endl;
             }
             cout << "--------\n";
             0 0 0 0 
             0 0 0 0
             0 0 0 0
             --------
                 
             // 初始化为row*column的矩阵，指定初始值
             int row = 3, column = 4;
             int init = 5;
             vector<vector<int>> matrix(row, vector<int>(column, init));
             for (auto outer : matrix)
             {
                 for (auto inner : outer)
                 {
                     cout << inner << " ";
                 }
                 cout << endl;
             }
             cout << "--------\n";
             5 5 5 5
             5 5 5 5
             5 5 5 5
             --------
                 
             // 初始化为row*column的矩阵，逐行初始化，指定初始值
             int row = 3, column = 4;
             int init = 5;
             vector<vector<int>> matrix;
             matrix.resize(row); //确定行数
             // 逐行确定列数
             for (int i = 0; i < row; i++)
             {
                 matrix[i].resize(column);
             }
             
             for (auto outer : matrix)
             {
                 for (auto inner : outer)
                 {
                     cout << inner << " ";
                 }
                 cout << endl;
             }
             cout << "--------\n";
             0 0 0 0
             0 0 0 0
             0 0 0 0
             --------
             ```

             

     - 63，不同路径+障碍

       - 还是到达[m]\[n\]处，但是路径上加了障碍
         - 还是一样讨论，有障碍，无非就是此处的方法数为0，然后初始化的时候注意一下
       - 1、数组含义：dp\[i\]\[j\]表示到达\[i\]\[j\]的方法数，0表示不可到达，也就是有障碍
         2、递推公式：
         if(obstacle\[i\]\[j\]==1) dp\[i\]\[j\]=0
         else dp\[i\]\[j\]=dp\[i-1\]\[j\]+dp\[i\]\[j-1\] 如果有障碍，dp被设为0，不影响结果
         3、初始化：第一行被设置为1，如果遇到阻碍，停止初始化；第一列也是如此
         4、遍历顺序：先横向，再纵向

     - 

     - 

     - 题目

- 

- 时间





# todo

- 回溯算法的周小结
- 双指针法
- 重新安排行程
- 491
- 513，找左下角递归
- 669，修剪二叉树
- 根据数组构造一棵高度平衡的二叉搜索树



- 实现堆
- 递归
  - 参数+返回值
  - 终止条件
  - 单层处理逻辑
- 一个可视化、自动生成最短路的pro
- 再看最小绝对差和众数



- 路由算法
- 拓扑控制
  - 检测到某个结点的关闭
  - 重新绘制拓扑结构

- 数字水印
- 

[2]: 
