

  - 2022年3月20日下午，dp-01背包
  - 474
- <img src="https://gitee.com/hit_whr/pic_2.0/raw/main/Screenshot_20220316_093252_com.newskyer.draw.jpg" alt="Screenshot_20220316_093252_com.newskyer.draw" style="zoom:50%;" />



- 这种最小、最大的问题，一般可以通过dp、贪心、回溯解决

  - 优先考虑dp，因为dp比贪心好想，有套路；因为dp比回溯时间复杂度比低
  - 其次考虑贪心，可能想不出来
  - 最后考虑回溯，因为有解决方法至少比没解决方法强

- 2022年3月22日下午，dp-完全背包

  - 322，最少硬币数

    - 给定coins数组，里面的元素表示硬币的面额

      给定面额和target

      要求硬币的面额之和为target

      如果可以构成，返回最少的硬币数，否则返回-1

      每种硬币的数量无限

    - dp

      - 完全背包问题，不涉及排列组合，所以背包和物品的遍历顺序不影响结果

        1、数组含义：dp[i]表示构成i的最小硬币数

        2、递推公式：dp[i] = min(dp[i], dp[i-coins] + 1)

        3、初始化：全0

        4、遍历顺序：完全背包，所以背包容量递增

        不涉及排列组合，所以背包和物品的遍历顺序不影响结果

      - **还需要注意初始化**

        - 这种涉及**最小值问题**的，**如果初始化为0，那么在后续比较过程中比较麻烦**，因为0一般是最小的，所以需要将0作为标志位进行校验

        - 另外一种方法是初始化为INT_MAX，这样就不会造成干扰

        - 四部曲

          1、数组含义：dp[i]表示构成i的最小硬币数

          2、递推公式：dp[i] = min(dp[i], dp[i-coins] + 1)

          3、初始化：dp[0]表示构成和为0的最小硬币数，dp[0] = 0

          **因为是求最小值，所以其他值不能初始化为0，应该初始化为INT_MAX**

          这样就可以在比较过程中自动识别不可行的方法，而不用逐个判断

          4、遍历顺序：完全背包，所以背包容量递增

    - 回溯（暴力搜索）

      - 横向遍历
        - 无重复值，不需要处理
      - 纵向遍历
        - 可以重复（找自己），不涉及排列顺序（不回头）
      - 结束条件
        - 路径和大于等于target
        - 用两个变量分别记录当前路径长度（初始化为0）和最短路径长度（INT_MAX）

  - 139，单词拆分

    给一个字符串s和字符串数组wordDict

    判断s是否能由wordDict中的字符串连接而成

    wordDict中的字符串可以被重复使用

    s = "leetcode", wordDict = ["leet","code"]

    true

    s = "applepenapple", wordDict = ["apple","pen"]

    true

    s = "catsandog", wordDict = ["cats","dog","sand","and","cat"]

    false

    - **这题的难点是遍历顺序选择**

      应该先容量再物品，这个可以通过自己推导感受到

      - 先容量再物品的好处在于排列：类似于排列数，可以考虑到物品的所有排列顺序，显然这题如果不考虑排列顺序，那么dp数组中必然要记录某个位置选择的物品

    - 四部曲

      1、数组含义：dp[i]表示是否可以用wordDict中的字符串构成s的前i个字符

      2、递推公式：dp[i] = dp[i] || dp[i-wordDict[i].size()]

      3、初始化：dp[0]=true,其余为false

      4、遍历顺序：因为物品可以被重复使用，所以背包容量递增

      先遍历背包容量再遍历物品

    - 推导过程

      比较过程

      ![Screenshot_20220322_155918_com.newskyer.draw](https://gitee.com/hit_whr/pic_2.0/raw/main/Screenshot_20220322_155918_com.newskyer.draw.jpg)

      总体过程

      ![Screenshot_20220322_155922_com.newskyer.draw](D:\Huawei Share\Huawei Share\Screenshot_20220322_155922_com.newskyer.draw.jpg)

- 背包问题遍历顺序总结

  - 对于01背包问题
    - 二维数组
      - 先遍历背包容量后遍历物品或者先遍历物品后遍历背包容量都可以
      - 只要背包容量递增，使得递推公式的右侧值提前被求出来就可以
    - 一维数组
      - 因为进行了数组压缩，使得物品索引没了，所以必须**先遍历物品，后遍历背包容量**
      - 在遍历背包容量时，因为不能重复选择，所以必须是**背包容量递减**
  - 对于完全背包问题
    - 一维数组
      - 在遍历背包容量时，因为可以重复选择，所以必须是**背包容量递增**
      - 先遍历背包容量还是先遍历物品？
        - **求组合数，先遍历物品**：518.零钱兑换II
        - **求排列数，先遍历背包容量**：377. 组合总和 Ⅳ、动态规划：70. 爬楼梯进阶版（完全背包）
        - **求最小数，都可以**：322. 零钱兑换、动态规划：279.完全平方数

- 2022年3月22日晚上，dp-打家劫舍

  - 198，打家劫舍

    - nums表示第i个屋子的价值

      要求不偷盗相邻的屋子

      返回偷盗的最大总价值

    - 四部曲

      1、数组含义：dp[i]表示偷盗到第i个屋子获得的最大总价值

      2、递推公式：dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])

      3、初始化：dp[0]=nums[0],dp[1]=max(nums[0],nums[1])

      4、遍历顺序：递增

  - 213，打家劫舍

    - nums表示第i个屋子的价值，这些屋子围成一个环

      要求不偷盗相邻的屋子

      返回偷盗的最大总价值

    - 第一个版本

      - 因为不能偷盗相邻的屋子，且第一个屋子和最后一个屋子相邻，所以考虑用标志来记录某个dp结果涉及第一个屋子，这个标志显然可以在遍历中传递，最后可以知道dp.back()的结果在运算中是否涉及第一个屋子

      - 但是无法解决[2,2,4,3,2,5]这个bug

        最后dp[5]=11,second=true,dp[4]=8

        输出为9

        而选择2,3,5可以到10

    - 第二个版本

      - 实际上就是第一个屋子和最后一个屋子不能同时被选择，那么不同时考虑这两个屋子即可。

        也就是说用两次dp

      - ```cpp
        class Solution2
        {
        public:
            int rob(vector<int> &nums)
            {
                if (nums.size() == 1)
                {
                    return nums[0];
                }
                vector<int> strip_last;
                strip_last.assign(nums.begin(), nums.begin() + nums.size() - 1);
                vector<int> strip_zero;
                strip_zero.assign(nums.begin() + 1, nums.end());
                return max(func(strip_zero), func(strip_last));
            }
            // 从nums序列中找到最大价值，此时不需要考虑环
            int func(vector<int> &nums)
            {
                if (nums.size() == 1)
                {
                    return nums[0];
                }
                vector<int> dp(nums.size());
                dp[0] = nums[0], dp[1] = max(nums[0], nums[1]);
                for (int i = 2; i < nums.size(); i++)
                {
                    dp[i] = max(dp[i - 1], nums[i] + dp[i - 2]);
                }
                return dp.back();
            }
        };
        ```

        

  - 337，打家劫舍

    - 所有屋子构成一棵二叉树

      要求偷盗某个结点后，不能再偷盗它的子节点

      返回偷盗的最大总价值

         3

        |  |

        4  5

       | |  |

       1 3  1

      结果为4+5=9

    - 递归

      - 第一个版本

        - 如果选择根节点，那么不能继续考虑左右儿子，只能考虑四个孙子；

          如果不考虑根节点，那么需要考虑左右儿子

        - 遍历顺序选择

          - 因为上面结点的计算需要依靠下面的结点，所以采用后序遍历

        - 递归三部曲

          - 参数和返回值
            - 根节点，从根节点出发偷盗的最大值
          - 递归出口
            - 如果为空，返回0
          - 处理逻辑
            - 考虑选择根节点和不选择根节点两种情况

        - 结果超时

          - 模拟一下就可以知道，进行了很多重复计算

            求根+四个孙子时计算孙子，求两个儿子时也会计算四个孙子

            应该用一个map来记录某个结点的最大值（根+四个孙子或两个儿子）

      - 第二个版本

        - 用一个map来记录求过结点的最大偷盗值，map查询的时间复杂度为O(1)

        - **注意在记录时，map放的位置。如果将map固定在返回值附近，逻辑比较清晰。**

        - ```cpp
          class Solution3
          {
          private:
              map<node *, int> my_map;
          
          public:
              int rob(node *root)
              {
                  if (root == nullptr)
                  {
                      return 0;
                  }
                  
                  // map中有记录
                  if (my_map.find(root) != my_map.end())
                  {
                      return my_map[root];
                  }
          
                  // 不放根节点
                  int left = rob(root->left), right = rob(root->right);
          
                  // 放根节点
                  int root_val = root->val;
                  if (root->left)
                  {
                      root_val += rob(root->left->left) + rob(root->left->right);
                  }
                  if (root->right)
                  {
                      root_val += rob(root->right->left) + rob(root->right->right);
                  }
          
                  // 保存计算结果
                  my_map[root] = max(left + right, root_val);
                  return my_map[root];
              }
          };
          ```

          

    - 树形dp

      - **对树进行动态规划，本身要和树的遍历结合在一起**

        本题选择后序遍历，因为根节点的结果依赖于儿子和孙子

        1、数组含义：dp[0]表示偷当前结点的最大值，dp[1]表示不偷当前结点的最大值

        **注意，在遍历这棵树之前，无法知道所有结点**

        **所以不能像背包问题一样提前定义好一个二维数组，然后用横坐标来表示物品**

        **只能将计算结果逐步通过递归的返回值送给上层结点**

        2、递推公式：

        3、初始化：dp[0]=dp[1]=0

        4、遍历顺序：后序遍历

      - ```cpp
        vector<int> postOrderTraverse(node *root)
        {
            if (root == nullptr)
            {
                return {0, 0};
            }
            // 左右子树偷与不偷根节点的最大值
            vector<int> left = postOrderTraverse(root->left);
            vector<int> right = postOrderTraverse(root->right);
        
            // 不偷根节点，左右子树的根节点可以偷也可以不偷
            int val1 = max(left[0], left[1]) + max(right[0], right[1]);
            // 偷根节点，不能偷左右子树的根节点
            int val2 = root->val + left[0] + right[0];
        
            return {val1, val2};
        }
        ```

      - 可以看到，计算根节点时，只需要左右子树的值，所以**不需要重复计算**

      - <img src="https://gitee.com/hit_whr/pic_2.0/raw/main/Screenshot_20220323_090612_com.newskyer.draw.jpg" alt="Screenshot_20220323_090612_com.newskyer.draw" style="zoom:50%;" />

    

- 2022年3月23日下午，递增子序列

  - 300，最长递增子序列

    - 给定一个数组，要求返回最长递增子序列的长度

      子序列不要求连续，递增是指严格递增

      nums = [10,9,2,5,3,7,101,18]

      Output: 4 [2,3,7,101]

    - 四部曲

      因为不要求连续，所以递推公式应该遍历之前的值

      1、数组含义：dp[i]表示前i个数的最长递增子序列的长度

      2、递推公式：需要考察前i-1个数，如果比第i个数小，dp[i]=max(dp[i],dp[j]+1)

      3、初始化：1，至少只放自己也满足严格递增的定义

      4、遍历顺序：递增

    - 注意最后一个值不一定是结果，也就是说最长递增子序列的最后一个值不一定是最后一个值

      应该取dp中的最大值

    - ![QQ图片20220323171749](https://gitee.com/hit_whr/pic_2.0/raw/main/QQ%E5%9B%BE%E7%89%8720220323171749.jpg)

  - 674，最长递增连续子序列

    - 给定一个数组nums，要求返回最长、严格递增、连续子序列的长度

      和300的区别就在于674要连续

      [1,3,5,4,7]

      结果为3。[1,3,5] [1,3,5,7]或[1,3,4,7]虽然更长，但是不连续

    - 1、数组含义：dp[i]表示前i个数的最长、严格递增、连续子序列的长度

      2、递推公式：dp[i] = dp[i-1]+1，如果nums[i]>nums[i-1]；否则维持原值，然后继续从1开始递增

      3、初始化：1

      4、遍历顺序：递增

      - <img src="https://gitee.com/hit_whr/pic_2.0/raw/main/image-20220323185716761.png" alt="image-20220323185716761" style="zoom:50%;" />

  - 718，最长公共子数组

    - 给定两个整数数组

      返回他们公共数组的最大长度

      公共数组应该连续

      nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]

      Output: 3

    - 四部曲

      1、数组含义：dp\[i][j]表示第一个数组以i结尾、第二个数组以j结尾时的公共子数组的最长长度

      2、递推公式：如果nums1[i]!=nums2[j]则dp[i]\[j]=0,否则dp\[i][j]=dp[i-1]\[j-1]+1

      3、初始化：dp\[0][j]=1 if nums1[0]==nums2[j],dp\[i][0]=1 if nums1[i]==nums2[0]

      4、遍历顺序：递增，递增

    - <img src="https://gitee.com/hit_whr/pic_2.0/raw/main/QQ%E5%9B%BE%E7%89%8720220323194216.jpg" alt="QQ图片20220323194216" style="zoom: 33%;" />

    - 压缩为一维数组

      - 注意递推公式dp\[i][j] = dp\[i - 1][j - 1] + 1;

        下一行在计算时只用到前一行的第j-1个值

        可以考虑压缩为一维数组然后递减遍历

        为什么可行？因为不会用到当前一行的值

        1、数组含义：dp[j+1]表示第二个数组以j结尾时，公共子数组的最长长度

        2、递推公式：如果nums1[i]!=nums2[j]则dp[j+1]=0(这里不同于二维数组，必须显式置零),否则dp[j+1]=dp[j]+1

        3、初始化：dp[0]=0

        4、遍历顺序：递减

      - 注意点

        - 二维数组因为初始化为全0且某个位置不会被重复使用，所以nums1[i]!=nums2[j]时，不需要显式修改dp为0

          而一维数组中某个位置会被重复使用，如果nums1[i]!=nums2[j]，表示i、j结尾时，数组值不相同，不存在这样的公共子数组，所以应该显式置零

        - ```cpp
          int findLength(vector<int> &nums1, vector<int> &nums2)
          {
              int max_length = 0;
              // 这里要补上一个0，防止越界
              vector<int> dp(nums2.size() + 1, 0);
              for (int i = 0; i < nums1.size(); i++)
              {
                  for (int j = nums2.size() - 1; j >= 0; j--)
                  {
                      if (nums2[j] == nums1[i])
                      {
                          // 因为dp前面补了一个0
                          dp[j + 1] = dp[j] + 1;
                          max_length = max(max_length, dp[j + 1]);
                      }
                      // 这里是一维数组和二维数组的区别
                      // 一维数组如果遇到nums1[i]!=nums2[j]，应该将dp[j+1]显式置零
                      // 不能让上一行的值代替本行的值，因为以nums1[i]和nums2[j]结尾的数组，最后一个值不相同
                      // 而二维数组不需要重复利用一块空间，所以不需要显式置零（因为都初始化为0）
                      else
                      {
                          dp[j + 1] = 0;
                      }
                  }
              }
              return max_length;
          }
          ```

          

  - 1143，最长公共子序列

    - 给定两个字符串，返回它们最长公共子序列的长度

      **子序列可以不连续**

      text1 = "abcde", text2 = "ace"

      Output: 3

    - 二维数组

      - 四部曲

        1、数组含义：dp\[i][j]表示两个字符串分别以i、j结尾时最长公共子序列的长度

        2、递推公式：if text1[i]==text2[j] then dp\[i][j]=max(dp\[m][n])+1,m<i,n<j

        否则维持0值（这里要求比较严格，必须是以i、j结尾，而后面的一维数组则不能这样考虑）

        3、初始化：0

        4、遍历顺序：递增，递增

      - 推导过程

        <img src="https://gitee.com/hit_whr/pic_2.0/raw/main/QQ%E5%9B%BE%E7%89%8720220323221248.jpg" alt="QQ图片20220323221248" style="zoom:50%;" />

      - **超时**

        - 因为内外两层循环是m*n，然后每次遇到相等的右边界，需要找到最大值，又是m\*n，所以总的时间复杂度为O(m^2\*n^2)

    - 一维数组

      - 四部曲

        上面的二维数组+遍历二维数组的子数组超时

        压缩为一维数组，然后对一维数组的子数组遍历，找最大值

        1、数组含义：dp[j]表示第二个字符串以j结尾时最长公共子序列的长度

        2、递推公式：if text1[i]==text2[j],dp[j]=max(dp[n])+1,n<j

        否则维持原值（必须维持原值，因为dp数组需要记录历史结果）

        为什么能这样？因为虽然dp数组定义为以j结尾，但是压缩后，可以不以j结尾

        因为dp数组还用来记录历史结果

        3、初始化：0

        4、遍历顺序：递增，递减

      - 注意这里内层循环必须递减

        - 如果递增，那么先算小的，而大的在计算时需要用到小的里面的最大值，但此时小的已经考虑了当前的text1[i]，所以重复考虑了

      - 推导过程

        - <img src="https://gitee.com/hit_whr/pic_2.0/raw/main/QQ%E5%9B%BE%E7%89%8720220323221252.jpg" alt="QQ图片20220323221252" style="zoom:50%;" />
        - ![QQ图片20220323221826](https://gitee.com/hit_whr/pic_2.0/raw/main/QQ%E5%9B%BE%E7%89%8720220323221826.jpg)
      
    - 二维数组改进
    
      - 上面的二维数组之所以需要遍历二维子数组，是因为当i、j不相等时维持了零值
    
        所以要向前遍历，找到零值
    
        实际上这不符合dp数组的定义，因为即使当前的两个字符不相等，由于不要求连续，所以可以继承dp[i]\[j-1]或dp\[i-1][j]中的最大值
    
      - 四部曲
    
        1、数组含义：dp\[i][j]表示两个字符串分别以i、j结尾时最长公共子序列的长度
    
        2、递推公式：if text1[i]==text2[j],dp\[i][j]=dp\[i-1][j-1]+1
    
        else dp\[i][j]=max(dp\[i][j-1],dp\[i-1][j])，也就是不考虑两个字符串中的某个最后字符
    
        3、初始化：注意到dp\[0][0]会越界，所以dp数组的行列都扩充一个单位
    
        4、遍历顺序：递增，递增
        
      - 推导过程
      
        <img src="https://gitee.com/hit_whr/pic_2.0/raw/main/QQ%E5%9B%BE%E7%89%8720220327204937.jpg" alt="QQ图片20220327204937" style="zoom:50%;" />

- 2022年3月27日晚上

  - 1035，不相交的线

    - 给定两个整数数组nums1、nums2

      将他们按照数组的顺序分别横放在两个水平线上

      从两个数组中国分别选取两个值，如果这两个值相同，且连线不会和已有连线相交，则连接这两个值

      并且，只能从一个数上引出一条线

      最后返回线的最大条数

      - 和上面的1143-两个字符串找最长公共子序列基本差不多

    - 四部曲

      1、数组含义：dp\[i][j]表示考虑第i、j个数时，最大的条数

      2、递推公式：if(nums1[i]==nums2[j]) dp\[i][j]=dp\[i-1][j-1]，此时肯定不会冲突

      else dp\[i][j]=max(dp\[i][j-1],dp\[i-1][j])

      3、初始化：0，越界，所以行列都增加一个单位

      4、遍历顺序：递增，递增

  - 53，最大子数组和

    - 给定一个整数数组nums

      返回某个连续数组的和，要求和最大

      [-2,1,-3,4,-1,2,1,-5,4]

      6 = [4,-1,2,1]

    - 贪心

      - 遍历数组，尝试更新最大和

        同时更新连续子数组的和，如果小于0，不可能对后续值有帮助，所以清零

      - 特别注意最大和、当前连续和的更新顺序

        - 因为连续和可能被更新为0，如果先求连续和，因为最大和会借用连续和，使得结果错误
        - 所以应该先更新最大和，再更新连续和

    - dp

      - 四部曲

        1、数组含义：dp[i]表示一定放第i个数时，最大子数组和

        这样能保证连续

        2、递推公式：dp[i]=max(dp[i-1]+nums[i],nums[i])

        因为必须放第i个数，所以，要么接上第i-1个数，要么不接上

        这个和674有点像，都是对一个数组进行操作

        3、初始化：dp[0]=nums[0]

        4、遍历顺序：递增

      - 递推公式的关键是，保证dp[i]一定取第i个值

      - 推导过程

        ![image-20220328143125236](https://gitee.com/hit_whr/pic_2.0/raw/main/image-20220328143125236.png)

  -  392，是否是子序列

    - 给定字符串s、t，判断s是不是t的子序列

      子序列是在不改变原序列元素相对位置的基础上，不删除或删除一些元素，得到的新序列

    - 四部曲

      1、数组含义：dp\[i\]\[j\]表示只考虑s的i个字符和t的j个字符时，是不是子序列
      2、递推公式：if s\[i\]==t\[j\], dp\[i\]\[j\]=dp\[i-1\]\[j-1\]
      else dp\[i\]\[j\]=dp\[i\]\[j-1\],这里只能是dp\[i\]\[j-1\]子串不能少，只能缩减原串
      3、初始化：为了防止越界，行列都需要多加一个单位
      dp\[i\]\[0\]，子串不为空，原串为空，false,i!=0
      dp\[0\]\[j\]，子串为空，原串空或不空，true
      4、遍历顺序：递增，递增

    - **这里两个字符串s、t，只能对t执行删除操作，因为可以删除原串的一些元素**

    - 推导过程

      ![image-20220328145739240](https://gitee.com/hit_whr/pic_2.0/raw/main/image-20220328145739240.png)

      
    
      <img src="https://gitee.com/hit_whr/pic_2.0/raw/main/QQ%E5%9B%BE%E7%89%8720220328082210.jpg" alt="QQ图片20220328082210" style="zoom:50%;" />

  

  -  115，子序列数

    - 给定字符串s、t，返回s的子序列中等于t的子序列数目

      s = "babgbag", t = "bag"

      Output: 5

    - 四部曲

      1、数组含义：dp\[i\]\[j\]表示考虑s的前i个字符，t的前j个字符的结果
      2、递推公式：if s\[i\]==t\[j\],dp\[i\]\[j\]=dp\[i-1\]\[j-1\]+dp\[i-1\]\[j\]
      前者表示t的最后一个字符来自s的最后一个字符，后者表示j的最后一个字符不来自s的最后一个字符
      else dp\[i\]\[j\]=dp\[i-1\]\[j\]，二者最后一个字符不同，只能缩减s，不能缩减t，因为t是子序列
      3、初始化：注意到可能越界，所以行列补一个单位
      dp\[i\]\[0\]=1,i>=0
      dp\[0\]\[j\]=0,j>0
      其余为0
      4、遍历顺序：递增，递增

    - **这里可以对s执行删除操作，因为也是找s的子序列**

      - 相比于上一题，这一题是求个数，所以当s、t的最后一个字符相同时，可以删除s、t的最后一个字符，表示t的最后一个字符来自此时s的最后一个字符；也可以只删除s的，表示t的最后一个字符并不来自此时s的最后一个字符
    
    - 整型溢出
    
      - leetcode给的一个测试数据很长，所以选择int、long类型的dp矩阵都溢出了，最后选择了unsigned long才满足
    
    - 推导过程
    
      <img src="https://gitee.com/hit_whr/pic_2.0/raw/main/QQ%E5%9B%BE%E7%89%8720220328151713.jpg" alt="QQ图片20220328151713" style="zoom:50%;" />
    
      
    
  -  583，删除字符数

    - 给定两个字符串word1，word2，返回使得word1==word2的最小步数

      每一步，都可以删除两个字符串中的任意一个字符

    - 四部曲

      1、数组含义：dp\[i\]\[j\]表示考虑word1的前i个字符、word2的前j个字符，所需要的最小步数
    2、递推公式：if word1\[i\]==word2\[j\], dp\[i\]\[j\]=dp\[i-1\]\[j-1\]，相同，不用删
      else dp\[i\]\[j\]=min(dp\[i-1\]\[j\]+1 ,dp\[i\]\[j-1\] +1,dp\[i-1\]\[j-1\]+2)
    删除word1的最后一个字符，删除word2最后一个字符，删除word1、word2的最后一个字符
      3、初始化：注意到可能溢出，所以给行列都增加一个单位
    dp\[0\]\[j\]=j,dp\[i\]\[0\]=i
      4、遍历顺序：递增，递增

    - 推导过程

      <img src="https://gitee.com/hit_whr/pic_2.0/raw/main/QQ%E5%9B%BE%E7%89%8720220328155642.jpg" alt="QQ图片20220328155642" style="zoom:50%;" />

      

  -  72，转化字符串

    - 给定字符串word1、word2，通过以下三种方式将word1转化为word2

      插入，删除，替换

      返回最少的操作数

      Input: word1 = "horse", word2 = "ros"

      Output: 3

      Explanation:

      horse -> rorse (replace 'h' with 'r')

      rorse -> rose (remove 'r')

      rose -> ros (remove 'e')

    - 四部曲

      1、数组含义：dp\[i\]\[j\]表示考虑word1的前i个字符，word2的前j个字符所需要的最少操作数
    2、递推公式：if word1\[i\]==word2\[j\], dp\[i\]\[j\]=dp\[i-1\]\[j-1\],相同则不需要操作
      else
    替换，替换之后肯定相同：dp\[i\]\[j\]=dp\[i-1\]\[j-1\]+1
      删除，只能删除word1中的最后一个字符：dp\[i\]\[j\]=dp\[i-1\]\[j\]+1
    增添，只能对word1进行增添：dp\[i\]\[j\]=dp\[i\]\[j-1\]+1
      最后取最小值
    3、初始化：dp\[0\]\[j\]=j，空串变j，增添j次
      dp\[i\]\[0\]=i，i变空串，删除i次
    4、遍历顺序：递增，递增
    
  - 这题主要就是考虑清楚不同的操作对应的递推公式
    
    - 当word1和word2的最后一个字符相同时，不需要对最后一个字符处理，所以最少操作数由前i-1、j-1个字符决定
      - 当word1和word2的最后一个字符不同时，需要最后一个字符进行处理，而处理方式有三种
      - 如果替换，只能替换word1的最后一个字符，使之和word2的最后一个字符相同，然后考虑word1的i-1个字符和word2的j-1个字符
        - 如果删除，只能删除word1的最后一个字符，删除后，考虑word1的i-1个字符和word2的j个字符
      - 如果增添，只能增添到word1的最后面，并且增添的是word2的最后一个字符，由于word1增添了字符，所以还是得考虑word1的i个字符，而word2只需要考虑j-1个字符
    
  - 推导过程

    <img src="https://gitee.com/hit_whr/pic_2.0/raw/main/QQ%E5%9B%BE%E7%89%8720220328160958.jpg" alt="QQ图片20220328160958" style="zoom:50%;" />

  - 总结一下上面四个题

    ![中心主题](https://gitee.com/hit_whr/pic_2.0/raw/main/%E4%B8%AD%E5%BF%83%E4%B8%BB%E9%A2%98.jpg)

- 2022年3月28日，下午

  - 647，回文子串的个数

    - 给定一个字符串s，返回s的子串中是回文串的子串的个数

      回文串：正序、逆序相同的字符串

      单个字符也是回文串，空串不是回文串

      子串：s的某个连续序列

    - dp

      - 四部曲

        1、数组含义：d\[i][j]表示字符串s以i开头、以j结尾时是否是回文串

        2、递推公式：

        if s[i]==s[j],i<=j

           if i==j-1, dp\[i][j]=true

           else if i==j, dp\[i][j]=true

           else dp[i][j]=dp\[i+1][j-1]

        else dp\[i][j]=false

        3、初始化：不用

        4、遍历顺序：递减(i会用到i+1)，递增(j会用到j-1)

        在遍历过程中，如果某个dp为true，则计数值++

    - 双指针法

      - 确定一个回文串，首先要确定中心，中心可以是一个元素如bab中的a，也可以是两个元素如baab中的aa

        确定中心后，向两侧检索，如果相同，则找到一个回文串

      - 时间复杂度也是n^2，但是空间复杂度是常数量级

        而dp的时间复杂度和空间复杂度都是n^2

  - 516，最长回文子序列的长度

    - 给定字符串s，返回最长回文子序列的长度

      回文：正序和逆序相同

      子序列：不要求连续

      Input: s = "bbbab"

      Output: 4

      Explanation: One possible longest palindromic subsequence is "bbbb".

    - dp版本1

      - 四部曲

        1、数组含义：dp\[i][j]表示s以i开头、j结尾时最长回文子序列的长度

        2、递推公式：

        j>=i

        if s[i]==s[j]

           if i==j,dp\[i][j]=1

           else if i==j-1,dp\[i][j]=2

           else dp\[i][j]=dp\[i+1][j-1]+2

        else dp\[i][j]=max(dp\[i+1][j],dp[i][j-1])

        3、初始化：0

        4、遍历顺序：递减，递增

        最后返回dp\[0][s.size()-1]

      - 推导过程

        <img src="https://gitee.com/hit_whr/pic_2.0/raw/main/QQ%E5%9B%BE%E7%89%8720220328201950.jpg" alt="QQ图片20220328201950" style="zoom:50%;" />

    - dp版本2

      - 四部曲

        1、数组含义：dp\[i\]\[j\]表示s以i开头、j结尾时最长回文子序列的长度
        2、递推公式：
        j>i
        if s\[i\]==s\[j\],dp\[i\]\[j\]=dp\[i+1\]\[j-1\]+2(进行了初始化，所以不需要考虑i==j或i==j-1)
        else dp\[i\]\[j\]=max(dp\[i+1\]\[j\],dp\[i\]\[j-1\])
        3、初始化：dp\[i\]\[i\]=1,else 0(防止干扰max)
        4、遍历顺序：递减，递增
        最后返回dp\[0\]\[s.size()-1\]

      - 推导过程

        ![QQ图片20220328201936](https://gitee.com/hit_whr/pic_2.0/raw/main/QQ%E5%9B%BE%E7%89%8720220328201936.jpg)

    - 版本1和版本2的不同

      - 二者主要是因为初始化的不同而导致递推公式和递推的起点不同
      - 版本1不进行初始化，所以在遍历过程中需要考虑ij的大小关系
      - 版本2对dp\[i][i]初始化，后面只需要保证j>i即可

  - 子序列与子串

    - 子串必须连续
    - 子序列可以不连续，只需要保持原来元素的相对位置

- 时间

  - 题目



# todo

- 动态规划适合解决一步解决不了，而需要不断迭代解决的问题
- 回溯
  - 698.划分为k个相等的子集
  - 473.火柴拼正方形