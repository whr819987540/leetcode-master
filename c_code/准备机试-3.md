

- 这种最小、最大的问题，一般可以通过dp、贪心、回溯解决

  - 优先考虑dp，因为dp比贪心好想，有套路；因为dp比回溯时间复杂度比低
  - 其次考虑贪心，可能想不出来
  - 最后考虑回溯，因为有解决方法至少比没解决方法强

- 2022年3月22日下午，dp-完全背包

  - 322，最少硬币数

    - 给定coins数组，里面的元素表示硬币的面额

      给定面额和target

      要求硬币的面额之和为target

      如果可以构成，返回最少的硬币数，否则返回-1

      每种硬币的数量无限

    - dp

      - 完全背包问题，不涉及排列组合，所以背包和物品的遍历顺序不影响结果

        1、数组含义：dp[i]表示构成i的最小硬币数

        2、递推公式：dp[i] = min(dp[i], dp[i-coins] + 1)

        3、初始化：全0

        4、遍历顺序：完全背包，所以背包容量递增

        不涉及排列组合，所以背包和物品的遍历顺序不影响结果

      - **还需要注意初始化**

        - 这种涉及**最小值问题**的，**如果初始化为0，那么在后续比较过程中比较麻烦**，因为0一般是最小的，所以需要将0作为标志位进行校验

        - 另外一种方法是初始化为INT_MAX，这样就不会造成干扰

        - 四部曲

          1、数组含义：dp[i]表示构成i的最小硬币数

          2、递推公式：dp[i] = min(dp[i], dp[i-coins] + 1)

          3、初始化：dp[0]表示构成和为0的最小硬币数，dp[0] = 0

          **因为是求最小值，所以其他值不能初始化为0，应该初始化为INT_MAX**

          这样就可以在比较过程中自动识别不可行的方法，而不用逐个判断

          4、遍历顺序：完全背包，所以背包容量递增

    - 回溯（暴力搜索）

      - 横向遍历
        - 无重复值，不需要处理
      - 纵向遍历
        - 可以重复（找自己），不涉及排列顺序（不回头）
      - 结束条件
        - 路径和大于等于target
        - 用两个变量分别记录当前路径长度（初始化为0）和最短路径长度（INT_MAX）

  - 139，单词拆分

    给一个字符串s和字符串数组wordDict

    判断s是否能由wordDict中的字符串连接而成

    wordDict中的字符串可以被重复使用

    s = "leetcode", wordDict = ["leet","code"]

    true

    s = "applepenapple", wordDict = ["apple","pen"]

    true

    s = "catsandog", wordDict = ["cats","dog","sand","and","cat"]

    false

    - **这题的难点是遍历顺序选择**

      应该先容量再物品，这个可以通过自己推导感受到

      - 先容量再物品的好处在于排列：类似于排列数，可以考虑到物品的所有排列顺序，显然这题如果不考虑排列顺序，那么dp数组中必然要记录某个位置选择的物品

    - 四部曲

      1、数组含义：dp[i]表示是否可以用wordDict中的字符串构成s的前i个字符

      2、递推公式：dp[i] = dp[i] || dp[i-wordDict[i].size()]

      3、初始化：dp[0]=true,其余为false

      4、遍历顺序：因为物品可以被重复使用，所以背包容量递增

      先遍历背包容量再遍历物品

    - 推导过程

      比较过程

      ![Screenshot_20220322_155918_com.newskyer.draw](https://gitee.com/hit_whr/pic_2.0/raw/main/Screenshot_20220322_155918_com.newskyer.draw.jpg)

      总体过程

      ![Screenshot_20220322_155922_com.newskyer.draw](D:\Huawei Share\Huawei Share\Screenshot_20220322_155922_com.newskyer.draw.jpg)

- 背包问题遍历顺序总结

  - 对于01背包问题
    - 二维数组
      - 先遍历背包容量后遍历物品或者先遍历物品后遍历背包容量都可以
      - 只要背包容量递增，使得递推公式的右侧值提前被求出来就可以
    - 一维数组
      - 因为进行了数组压缩，使得物品索引没了，所以必须**先遍历物品，后遍历背包容量**
      - 在遍历背包容量时，因为不能重复选择，所以必须是**背包容量递减**
  - 对于完全背包问题
    - 一维数组
      - 在遍历背包容量时，因为可以重复选择，所以必须是**背包容量递增**
      - 先遍历背包容量还是先遍历物品？
        - **求组合数，先遍历物品**：518.零钱兑换II
        - **求排列数，先遍历背包容量**：377. 组合总和 Ⅳ、动态规划：70. 爬楼梯进阶版（完全背包）
        - **求最小数，都可以**：322. 零钱兑换、动态规划：279.完全平方数

- 2022年3月22日晚上，dp-打家劫舍

  - 198，打家劫舍

    - nums表示第i个屋子的价值

      要求不偷盗相邻的屋子

      返回偷盗的最大总价值

    - 四部曲

      1、数组含义：dp[i]表示偷盗到第i个屋子获得的最大总价值

      2、递推公式：dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])

      3、初始化：dp[0]=nums[0],dp[1]=max(nums[0],nums[1])

      4、遍历顺序：递增

  - 213，打家劫舍

    - nums表示第i个屋子的价值，这些屋子围成一个环

      要求不偷盗相邻的屋子

      返回偷盗的最大总价值

    - 第一个版本

      - 因为不能偷盗相邻的屋子，且第一个屋子和最后一个屋子相邻，所以考虑用标志来记录某个dp结果涉及第一个屋子，这个标志显然可以在遍历中传递，最后可以知道dp.back()的结果在运算中是否涉及第一个屋子

      - 但是无法解决[2,2,4,3,2,5]这个bug

        最后dp[5]=11,second=true,dp[4]=8

        输出为9

        而选择2,3,5可以到10

    - 第二个版本

      - 实际上就是第一个屋子和最后一个屋子不能同时被选择，那么不同时考虑这两个屋子即可。

        也就是说用两次dp

      - ```cpp
        class Solution2
        {
        public:
            int rob(vector<int> &nums)
            {
                if (nums.size() == 1)
                {
                    return nums[0];
                }
                vector<int> strip_last;
                strip_last.assign(nums.begin(), nums.begin() + nums.size() - 1);
                vector<int> strip_zero;
                strip_zero.assign(nums.begin() + 1, nums.end());
                return max(func(strip_zero), func(strip_last));
            }
            // 从nums序列中找到最大价值，此时不需要考虑环
            int func(vector<int> &nums)
            {
                if (nums.size() == 1)
                {
                    return nums[0];
                }
                vector<int> dp(nums.size());
                dp[0] = nums[0], dp[1] = max(nums[0], nums[1]);
                for (int i = 2; i < nums.size(); i++)
                {
                    dp[i] = max(dp[i - 1], nums[i] + dp[i - 2]);
                }
                return dp.back();
            }
        };
        ```

        

  - 337，打家劫舍

    - 所有屋子构成一棵二叉树

      要求偷盗某个结点后，不能再偷盗它的子节点

      返回偷盗的最大总价值

         3

        |  |

        4  5

       | |  |

       1 3  1

      结果为4+5=9

    - 递归

      - 第一个版本

        - 如果选择根节点，那么不能继续考虑左右儿子，只能考虑四个孙子；

          如果不考虑根节点，那么需要考虑左右儿子

        - 遍历顺序选择

          - 因为上面结点的计算需要依靠下面的结点，所以采用后序遍历

        - 递归三部曲

          - 参数和返回值
            - 根节点，从根节点出发偷盗的最大值
          - 递归出口
            - 如果为空，返回0
          - 处理逻辑
            - 考虑选择根节点和不选择根节点两种情况

        - 结果超时

          - 模拟一下就可以知道，进行了很多重复计算

            求根+四个孙子时计算孙子，求两个儿子时也会计算四个孙子

            应该用一个map来记录某个结点的最大值（根+四个孙子或两个儿子）

      - 第二个版本

        - 用一个map来记录求过结点的最大偷盗值，map查询的时间复杂度为O(1)

        - **注意在记录时，map放的位置。如果将map固定在返回值附近，逻辑比较清晰。**

        - ```cpp
          class Solution3
          {
          private:
              map<node *, int> my_map;
          
          public:
              int rob(node *root)
              {
                  if (root == nullptr)
                  {
                      return 0;
                  }
                  
                  // map中有记录
                  if (my_map.find(root) != my_map.end())
                  {
                      return my_map[root];
                  }
          
                  // 不放根节点
                  int left = rob(root->left), right = rob(root->right);
          
                  // 放根节点
                  int root_val = root->val;
                  if (root->left)
                  {
                      root_val += rob(root->left->left) + rob(root->left->right);
                  }
                  if (root->right)
                  {
                      root_val += rob(root->right->left) + rob(root->right->right);
                  }
          
                  // 保存计算结果
                  my_map[root] = max(left + right, root_val);
                  return my_map[root];
              }
          };
          ```

          

    - 树形dp

      - **对树进行动态规划，本身要和树的遍历结合在一起**

        本题选择后序遍历，因为根节点的结果依赖于儿子和孙子

        1、数组含义：dp[0]表示偷当前结点的最大值，dp[1]表示不偷当前结点的最大值

        **注意，在遍历这棵树之前，无法知道所有结点**

        **所以不能像背包问题一样提前定义好一个二维数组，然后用横坐标来表示物品**

        **只能将计算结果逐步通过递归的返回值送给上层结点**

        2、递推公式：

        3、初始化：dp[0]=dp[1]=0

        4、遍历顺序：后序遍历

      - ```cpp
        vector<int> postOrderTraverse(node *root)
        {
            if (root == nullptr)
            {
                return {0, 0};
            }
            // 左右子树偷与不偷根节点的最大值
            vector<int> left = postOrderTraverse(root->left);
            vector<int> right = postOrderTraverse(root->right);
        
            // 不偷根节点，左右子树的根节点可以偷也可以不偷
            int val1 = max(left[0], left[1]) + max(right[0], right[1]);
            // 偷根节点，不能偷左右子树的根节点
            int val2 = root->val + left[0] + right[0];
        
            return {val1, val2};
        }
        ```

      - 可以看到，计算根节点时，只需要左右子树的值，所以**不需要重复计算**

      - <img src="https://gitee.com/hit_whr/pic_2.0/raw/main/Screenshot_20220323_090612_com.newskyer.draw.jpg" alt="Screenshot_20220323_090612_com.newskyer.draw" style="zoom:50%;" />

    

- 2022年3月23日下午，递增子序列

  - 300，最长递增子序列

    - 给定一个数组，要求返回最长递增子序列的长度

      子序列不要求连续，递增是指严格递增

      nums = [10,9,2,5,3,7,101,18]

      Output: 4 [2,3,7,101]

    - 四部曲

      因为不要求连续，所以递推公式应该遍历之前的值

      1、数组含义：dp[i]表示前i个数的最长递增子序列的长度

      2、递推公式：需要考察前i-1个数，如果比第i个数小，dp[i]=max(dp[i],dp[j]+1)

      3、初始化：1，至少只放自己也满足严格递增的定义

      4、遍历顺序：递增

    - 注意最后一个值不一定是结果，也就是说最长递增子序列的最后一个值不一定是最后一个值

      应该取dp中的最大值

    - ![QQ图片20220323171749](https://gitee.com/hit_whr/pic_2.0/raw/main/QQ%E5%9B%BE%E7%89%8720220323171749.jpg)

  - 674，最长递增连续子序列

    - 给定一个数组nums，要求返回最长、严格递增、连续子序列的长度

      和300的区别就在于674要连续

      [1,3,5,4,7]

      结果为3。[1,3,5] [1,3,5,7]或[1,3,4,7]虽然更长，但是不连续

    - 1、数组含义：dp[i]表示前i个数的最长、严格递增、连续子序列的长度

      2、递推公式：dp[i] = dp[i-1]+1，如果nums[i]>nums[i-1]；否则维持原值，然后继续从1开始递增

      3、初始化：1

      4、遍历顺序：递增

      - <img src="https://gitee.com/hit_whr/pic_2.0/raw/main/image-20220323185716761.png" alt="image-20220323185716761" style="zoom:50%;" />

  - 718，最长公共子数组

    - 给定两个整数数组

      返回他们公共数组的最大长度

      公共数组应该连续

      nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]

      Output: 3

    - 四部曲

      1、数组含义：dp\[i][j]表示第一个数组以i结尾、第二个数组以j结尾时的公共子数组的最长长度

      2、递推公式：如果nums1[i]!=nums2[j]则dp[i]\[j]=0,否则dp\[i][j]=dp[i-1]\[j-1]+1

      3、初始化：dp\[0][j]=1 if nums1[0]==nums2[j],dp\[i][0]=1 if nums1[i]==nums2[0]

      4、遍历顺序：递增，递增

    - <img src="https://gitee.com/hit_whr/pic_2.0/raw/main/QQ%E5%9B%BE%E7%89%8720220323194216.jpg" alt="QQ图片20220323194216" style="zoom: 33%;" />

    - 压缩为一维数组

      - 注意递推公式dp\[i][j] = dp\[i - 1][j - 1] + 1;

        下一行在计算时只用到前一行的第j-1个值

        可以考虑压缩为一维数组然后递减遍历

        为什么可行？因为不会用到当前一行的值

        1、数组含义：dp[j+1]表示第二个数组以j结尾时，公共子数组的最长长度

        2、递推公式：如果nums1[i]!=nums2[j]则dp[j+1]=0(这里不同于二维数组，必须显式置零),否则dp[j+1]=dp[j]+1

        3、初始化：dp[0]=0

        4、遍历顺序：递减

      - 注意点

        - 二维数组因为初始化为全0且某个位置不会被重复使用，所以nums1[i]!=nums2[j]时，不需要显式修改dp为0

          而一维数组中某个位置会被重复使用，如果nums1[i]!=nums2[j]，表示i、j结尾时，数组值不相同，不存在这样的公共子数组，所以应该显式置零

        - ```cpp
          int findLength(vector<int> &nums1, vector<int> &nums2)
          {
              int max_length = 0;
              // 这里要补上一个0，防止越界
              vector<int> dp(nums2.size() + 1, 0);
              for (int i = 0; i < nums1.size(); i++)
              {
                  for (int j = nums2.size() - 1; j >= 0; j--)
                  {
                      if (nums2[j] == nums1[i])
                      {
                          // 因为dp前面补了一个0
                          dp[j + 1] = dp[j] + 1;
                          max_length = max(max_length, dp[j + 1]);
                      }
                      // 这里是一维数组和二维数组的区别
                      // 一维数组如果遇到nums1[i]!=nums2[j]，应该将dp[j+1]显式置零
                      // 不能让上一行的值代替本行的值，因为以nums1[i]和nums2[j]结尾的数组，最后一个值不相同
                      // 而二维数组不需要重复利用一块空间，所以不需要显式置零（因为都初始化为0）
                      else
                      {
                          dp[j + 1] = 0;
                      }
                  }
              }
              return max_length;
          }
          ```

          

  - 1143，最长公共子序列

    - 给定两个字符串，返回它们最长公共子序列的长度

      **子序列可以不连续**

      text1 = "abcde", text2 = "ace"

      Output: 3

    - 二维数组

      - 四部曲

        1、数组含义：dp\[i][j]表示两个字符串分别以i、j结尾时最长公共子序列的长度

        2、递推公式：if text1[i]==text2[j] then dp\[i][j]=max(dp\[m][n])+1,m<i,n<j

        否则维持0值（这里要求比较严格，必须是以i、j结尾，而后面的一维数组则不能这样考虑）

        3、初始化：0

        4、遍历顺序：递增，递增

      - 推导过程

        <img src="https://gitee.com/hit_whr/pic_2.0/raw/main/QQ%E5%9B%BE%E7%89%8720220323221248.jpg" alt="QQ图片20220323221248" style="zoom:50%;" />

      - **超时**

        - 因为内外两层循环是m*n，然后每次遇到相等的右边界，需要找到最大值，又是m\*n，所以总的时间复杂度为O(m^2\*n^2)

    - 一维数组

      - 四部曲

        上面的二维数组+遍历二维数组的子数组超时

        压缩为一维数组，然后对一维数组的子数组遍历，找最大值

        1、数组含义：dp[j]表示第二个字符串以j结尾时最长公共子序列的长度

        2、递推公式：if text1[i]==text2[j],dp[j]=max(dp[n])+1,n<j

        否则维持原值（必须维持原值，因为dp数组需要记录历史结果）

        为什么能这样？因为虽然dp数组定义为以j结尾，但是压缩后，可以不以j结尾

        因为dp数组还用来记录历史结果

        3、初始化：0

        4、遍历顺序：递增，递减

      - 注意这里内层循环必须递减

        - 如果递增，那么先算小的，而大的在计算时需要用到小的里面的最大值，但此时小的已经考虑了当前的text1[i]，所以重复考虑了

      - 推导过程

        - <img src="https://gitee.com/hit_whr/pic_2.0/raw/main/QQ%E5%9B%BE%E7%89%8720220323221252.jpg" alt="QQ图片20220323221252" style="zoom:50%;" />
        - ![QQ图片20220323221826](https://gitee.com/hit_whr/pic_2.0/raw/main/QQ%E5%9B%BE%E7%89%8720220323221826.jpg)

- 

- 

- 

- 

- 时间

  - 题目



# todo

- 回溯
  - 698.划分为k个相等的子集
  - 473.火柴拼正方形